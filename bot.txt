/**
 * æ¾³é—¨å…­åˆå½©é¢„æµ‹æœºå™¨äºº (Macau Mark Six Prediction Bot)
 * ç‰ˆæœ¬: V5.0 Enterprise Complete Edition (ä¿®å¤ç‰ˆ)
 * ä¿®å¤: é¢‘é“æ¶ˆæ¯ä¸è§¦å‘AIåŠ©æ‰‹ï¼Œé¿å…æ— é™å¾ªç¯
 * 
 * ==============================================================================
 * æ ¸å¿ƒåŠŸèƒ½æ¸…å•:
 * 1. ç¡®å®šæ€§é¢„æµ‹å¼•æ“ (Deterministic Prediction Engine)
 *    - åŸºäºé©¬å°”å¯å¤«é“¾ (Markov Chain)
 *    - åŸºäºé—æ¼å€¼å›å½’ (Omission Regression)
 *    - åŸºäºåŠ æƒç§»åŠ¨å¹³å‡ (Weighted Moving Average)
 * 2. æ—¶å…‰æœºå¤ç›˜ç³»ç»Ÿ (Time-Machine Backtesting)
 *    - æ”¯æŒå›æ»šè‡³ä»»æ„å†å²æœŸæ•°
 *    - æ¨¡æ‹Ÿå½“æ—¶çš„é¢„æµ‹ç¯å¢ƒ
 *    - è‡ªåŠ¨å¯¹æ¯”çœŸå®ç»“æœ
 * 3. è‡ªä¸»å­¦ä¹ è¿›åŒ–ç³»ç»Ÿ (Self-Evolution Learning)
 *    - é¢„æµ‹å¤±è´¥è‡ªåŠ¨åˆ†æåŸå› 
 *    - åŠ¨æ€è°ƒæ•´ç®—æ³•æƒé‡å‚æ•°
 *    - å‚æ•°æŒä¹…åŒ–å­˜å‚¨
 * 4. ç³»ç»Ÿç®¡ç†åŠŸèƒ½
 *    - å†å²æ•°æ®ä» URL åŒæ­¥
 *    - å®šæ—¶è‡ªåŠ¨æ¨é€ï¼ˆå®Œæ•´å®ç°ï¼‰
 *    - æˆ˜ç»©ç»Ÿè®¡ä¸å½’æ¡£
 *    - AI åŠ©æ‰‹é›†æˆ
 * 5. å®Œæ•´ç”¨æˆ·ç•Œé¢
 *    - Telegram Bot å…¨åŠŸèƒ½èœå•
 *    - å®æ—¶äº¤äº’åé¦ˆ
 *    - å¤šçŠ¶æ€ç®¡ç†
 * ==============================================================================
 */

// ==============================================================================
// 1. å…¨å±€é…ç½®ä¸å¸¸é‡å®šä¹‰ (Global Configuration & Constants)
// ==============================================================================

const CONFIG = {
  // ç³»ç»ŸåŸºç¡€è®¾ç½®
  SYSTEM: {
    NAME: "ğŸ‡²ğŸ‡´ æ–°æ¾³å…­åˆå½©Â·å¤©æœº",
    VERSION: "V5.0 Enterprise Complete (ä¿®å¤ç‰ˆ)",
    DEFAULT_DURATION: 3 * 60 * 60 * 1000, // é»˜è®¤è®¡ç®—æ—¶é•¿
    TARGET_SIMS: 5000000,                 // ç›®æ ‡æ¨¡æ‹Ÿæ¬¡æ•°
    BATCH_SIZE: 50000,                    // æ¯æ¬¡æ‰§è¡Œæ‰¹æ¬¡
    AI_MODEL: "@cf/meta/llama-3-8b-instruct",
    TIMEZONE_OFFSET: 8,                   // UTC+8 åŒ—äº¬æ—¶é—´
    CHANNEL_ID: null,                     // ä»ç¯å¢ƒå˜é‡è·å–
    ADMIN_ID: null                        // ä»ç¯å¢ƒå˜é‡è·å–
  },

  // åˆå§‹ç®—æ³•æƒé‡
  DEFAULT_ALGO_WEIGHTS: {
    w_freq: 1.0,      // åŸºç¡€é¢‘ç‡æƒé‡
    w_markov: 2.5,    // é©¬å°”å¯å¤«è½¬ç§»æƒé‡
    w_omission: 0.8,  // é—æ¼åç¦»æƒé‡
    w_relation: 1.5,  // ç”Ÿè‚–å…³ç³»æƒé‡
    w_color: 1.0,     // æ³¢è‰²æƒé‡
    w_tail: 1.0,      // å°¾æ•°æƒé‡
    w_shape: 0.8      // å½¢æ€æƒé‡
  },

  // ç”Ÿè‚–æ˜ å°„è¡¨
  ZODIAC_MAP: {
    "è›‡": [1, 13, 25, 37, 49],
    "é¾™": [2, 14, 26, 38],
    "å…”": [3, 15, 27, 39],
    "è™": [4, 16, 28, 40],
    "ç‰›": [5, 17, 29, 41],
    "é¼ ": [6, 18, 30, 42],
    "çŒª": [7, 19, 31, 43],
    "ç‹—": [8, 20, 32, 44],
    "é¸¡": [9, 21, 33, 45],
    "çŒ´": [10, 22, 34, 46],
    "ç¾Š": [11, 23, 35, 47],
    "é©¬": [12, 24, 36, 48]
  },

  // äº”è¡Œ/å…³ç³»å®šä¹‰
  RELATIONS: {
    // å…­åˆï¼šäº’ç›¸è´µäººï¼Œå¼ºå…³è”
    LIU_HE: {
      "é¼ ": "ç‰›", "ç‰›": "é¼ ", "è™": "çŒª", "çŒª": "è™", "å…”": "ç‹—", "ç‹—": "å…”",
      "é¾™": "é¸¡", "é¸¡": "é¾™", "è›‡": "çŒ´", "çŒ´": "è›‡", "é©¬": "ç¾Š", "ç¾Š": "é©¬"
    },
    // ä¸‰åˆï¼šæ˜åˆï¼Œè¿åŠ¿ç›¸ç”Ÿ
    SAN_HE: {
      "é¼ ": ["é¾™", "çŒ´"], "ç‰›": ["è›‡", "é¸¡"], "è™": ["é©¬", "ç‹—"], "å…”": ["ç¾Š", "çŒª"],
      "é¾™": ["é¼ ", "çŒ´"], "è›‡": ["ç‰›", "é¸¡"], "é©¬": ["è™", "ç‹—"], "ç¾Š": ["å…”", "çŒª"],
      "çŒ´": ["é¼ ", "é¾™"], "é¸¡": ["ç‰›", "è›‡"], "ç‹—": ["è™", "é©¬"], "çŒª": ["å…”", "ç¾Š"]
    },
    // ç›¸å†²ï¼šå¯¹ç«‹å…³ç³»
    CHONG: {
      "é¼ ": "é©¬", "é©¬": "é¼ ", "ç‰›": "ç¾Š", "ç¾Š": "ç‰›", "è™": "çŒ´", "çŒ´": "è™",
      "å…”": "é¸¡", "é¸¡": "å…”", "é¾™": "ç‹—", "ç‹—": "é¾™", "è›‡": "çŒª", "çŒª": "è›‡"
    }
  },

  // æ³¢è‰²å®šä¹‰
  COLORS: {
    red: [1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46],
    blue: [3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48],
    green: [5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49]
  },

  // è¡¨æƒ…ç¬¦å·æ˜ å°„
  EMOJI: {
    red: "ğŸ”´",
    blue: "ğŸ”µ",
    green: "ğŸŸ¢",
    win: "âœ…",
    loss: "âŒ",
    wait: "â³",
    chart: "ğŸ“Š",
    bot: "ğŸ¤–",
    fire: "ğŸ”¥",
    shield: "ğŸ›¡ï¸",
    rocket: "ğŸš€",
    sync: "ğŸ”„",
    reset: "â™»ï¸",
    clock: "â°",
    auto: "ğŸ“¡",
    manage: "âš™ï¸",
    history: "ğŸ“œ",
    score: "ğŸ†",
    preview: "ğŸ‘€",
    back: "ğŸ”™",
    help: "â“",
    learn: "ğŸ§ ",
    calendar: "ğŸ“…",
    bell: "ğŸ””"
  }
};

// æŒ‰é’®æ–‡æœ¬å¸¸é‡
const BTNS = {
  REC: `${CONFIG.EMOJI.history} å†å²è®°å½•`,
  MANAGE: `${CONFIG.EMOJI.manage} ç³»ç»Ÿç®¡ç†`,
  SCORE: `${CONFIG.EMOJI.score} é¢„æµ‹æˆ˜ç»©`,
  PREVIEW: `${CONFIG.EMOJI.preview} é¢„è§ˆé¢„æµ‹`,
  PUSH: `${CONFIG.EMOJI.rocket} ç«‹å³æ¨é€`,
  RESET: `${CONFIG.EMOJI.reset} é‡ç½®ä»»åŠ¡`,
  TIME: `${CONFIG.EMOJI.clock} è¿ç®—æ—¶é•¿`,
  AUTO: `${CONFIG.EMOJI.auto} è‡ªåŠ¨æ¨é€`,
  SYNC: `${CONFIG.EMOJI.sync} åŒæ­¥æ•°æ®`,
  BACK: `${CONFIG.EMOJI.back} è¿”å›èœå•`,
  LEARN: `${CONFIG.EMOJI.learn} å¼ºåˆ¶å­¦ä¹ `,
  HELP: `${CONFIG.EMOJI.help} ä½¿ç”¨å¸®åŠ©`,
  SCHEDULE: `${CONFIG.EMOJI.calendar} å®šæ—¶è®¾ç½®`,
  STATUS: `${CONFIG.EMOJI.bell} ç³»ç»ŸçŠ¶æ€`
};

// é”®ç›˜å¸ƒå±€å®šä¹‰ï¼ˆå®Œæ•´ç‰ˆï¼‰
const KEYBOARDS = {
  LOBBY: {
    keyboard: [
      [{ text: CONFIG.SYSTEM.NAME }],
      [{ text: "ğŸ¤– AI åŠ©æ‰‹" }, { text: BTNS.HELP }],
      [{ text: BTNS.STATUS }]
    ],
    resize_keyboard: true,
    persistent: true
  },

  MAIN_MENU: {
    keyboard: [
      [{ text: BTNS.REC }, { text: BTNS.SCORE }],
      [{ text: BTNS.PREVIEW }],
      [{ text: BTNS.MANAGE }],
      [{ text: "ğŸ”™ è¿”å›å¤§å…" }, { text: BTNS.HELP }]
    ],
    resize_keyboard: true
  },

  ADMIN_MENU: {
    keyboard: [
      [{ text: BTNS.PUSH }, { text: BTNS.RESET }],
      [{ text: BTNS.AUTO }, { text: BTNS.TIME }],
      [{ text: BTNS.SYNC }, { text: BTNS.SCHEDULE }],
      [{ text: BTNS.LEARN }, { text: BTNS.STATUS }],
      [{ text: BTNS.BACK }]
    ],
    resize_keyboard: true
  },

  TIME_SETTINGS: {
    keyboard: [
      [{ text: "SET_DUR_1" }, { text: "SET_DUR_3" }, { text: "SET_DUR_5" }],
      [{ text: "SET_DUR_8" }, { text: "SET_DUR_12" }],
      [{ text: BTNS.BACK }]
    ],
    resize_keyboard: true
  },

  SCHEDULE_SETTINGS: {
    keyboard: [
      [{ text: "å®šæ—¶ 08:00" }, { text: "å®šæ—¶ 12:00" }, { text: "å®šæ—¶ 18:00" }],
      [{ text: "å®šæ—¶ 20:00" }, { text: "å®šæ—¶ 22:00" }],
      [{ text: "å®šæ—¶å…³é—­" }, { text: "æŸ¥çœ‹å®šæ—¶" }],
      [{ text: BTNS.BACK }]
    ],
    resize_keyboard: true
  },

  AI_CHAT: {
    keyboard: [[{ text: "ğŸ”™ è¿”å›å¤§å…" }]],
    resize_keyboard: true
  }
};

// ==============================================================================
// 2. å·¥å…·ç±»ä¸è¾…åŠ©å‡½æ•° (Utilities & Helpers)
// ==============================================================================

/**
 * æ—¥å¿—è®°å½•å™¨
 */
class Logger {
  static info(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.log(`[${timestamp}] [INFO] [${context}] ${message}`);
  }

  static error(context, message, error = null) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.error(`[${timestamp}] [ERROR] [${context}] ${message}`, error ? error : '');
  }

  static warn(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.warn(`[${timestamp}] [WARN] [${context}] ${message}`);
  }

  static debug(context, message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
    console.debug(`[${timestamp}] [DEBUG] [${context}] ${message}`);
  }
}

/**
 * æ ¼å¼åŒ–å·¥å…·
 */
class Formatter {
  /**
   * æ ¹æ®æ•°å­—è·å–å±æ€§ï¼ˆç”Ÿè‚–ã€æ³¢è‰²ï¼‰
   */
  static getAttributes(number) {
    const num = parseInt(number);
    if (num < 1 || num > 49) return { zodiac: "æœªçŸ¥", color: "æœªçŸ¥" };
    
    let color = "red";
    if (CONFIG.COLORS.blue.includes(num)) color = "blue";
    else if (CONFIG.COLORS.green.includes(num)) color = "green";

    let zodiac = "";
    for (const [zodiacName, numbers] of Object.entries(CONFIG.ZODIAC_MAP)) {
      if (numbers.includes(num)) {
        zodiac = zodiacName;
        break;
      }
    }
    return { zodiac, color };
  }

  /**
   * æ ¼å¼åŒ–å¼€å¥–å·ç æ˜¾ç¤º
   */
  static formatOpenCode(codeString) {
    return codeString.replace(/,/g, "-");
  }

  /**
   * è·å–å½“å‰åŒ—äº¬æ—¶é—´
   */
  static getBeijingTime() {
    const now = new Date();
    const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
    return new Date(utc + (3600000 * CONFIG.SYSTEM.TIMEZONE_OFFSET));
  }

  /**
   * æ ¼å¼åŒ–åŒ—äº¬æ—¶é—´å­—ç¬¦ä¸²
   */
  static formatBeijingTime(date = null) {
    const d = date || this.getBeijingTime();
    return d.toISOString().replace('T', ' ').substr(0, 19) + " (UTC+8)";
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º (HH:MM)
   */
  static formatTime(timeStr) {
    if (!timeStr || timeStr === "OFF") return "æœªè®¾ç½®";
    return timeStr;
  }

  /**
   * ç”Ÿæˆè¿›åº¦æ¡
   */
  static generateProgressBar(current, total, length = 10) {
    const percentage = total > 0 ? (current / total) : 0;
    const filled = Math.floor(length * percentage);
    const empty = length - filled;
    return "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
  }
}

/**
 * ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨
 */
class UserStateManager {
  constructor() {
    this.states = new Map();
  }

  setState(userId, state) {
    this.states.set(userId, {
      ...state,
      timestamp: Date.now(),
      lastActivity: Date.now()
    });
    this.cleanup();
  }

  getState(userId) {
    const state = this.states.get(userId);
    if (state && Date.now() - state.timestamp < 30 * 60 * 1000) { // 30åˆ†é’Ÿæœ‰æ•ˆæœŸ
      state.lastActivity = Date.now();
      return state;
    }
    this.states.delete(userId);
    return null;
  }

  updateState(userId, updates) {
    const state = this.getState(userId);
    if (state) {
      this.states.set(userId, {
        ...state,
        ...updates,
        lastActivity: Date.now()
      });
      return true;
    }
    return false;
  }

  deleteState(userId) {
    this.states.delete(userId);
  }

  cleanup() {
    const now = Date.now();
    for (const [userId, state] of this.states.entries()) {
      if (now - state.lastActivity > 30 * 60 * 1000) {
        this.states.delete(userId);
      }
    }
  }
}

const userStateManager = new UserStateManager();

// ==============================================================================
// 3. æ•°æ®åº“æ“ä½œå±‚ (Database Access Layer) - å®Œæ•´ç‰ˆ
// ==============================================================================

const DB = {
  /**
   * è·å–å†å²è®°å½•
   */
  getHistory: async (env, limit = null, offset = 0) => {
    try {
      let sql = "SELECT * FROM lottery_history ORDER BY expect DESC";
      let params = [];
      if (limit) {
        sql += " LIMIT ? OFFSET ?";
        params.push(limit, offset);
      }
      const { results } = await env.DB.prepare(sql).bind(...params).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getHistory failed", e);
      return [];
    }
  },

  /**
   * è·å–è®°å½•æ€»æ•°
   */
  getHistoryCount: async (env) => {
    try {
      const result = await env.DB.prepare("SELECT COUNT(*) as count FROM lottery_history").first();
      return result ? result.count : 0;
    } catch (e) {
      Logger.error("DB", "getHistoryCount failed", e);
      return 0;
    }
  },

  /**
   * è·å–æŒ‡å®šæœŸå·çš„å†å²è®°å½•
   */
  getHistoryByExpect: async (env, expect) => {
    try {
      const result = await env.DB.prepare(
        "SELECT * FROM lottery_history WHERE expect = ? ORDER BY expect DESC"
      ).bind(expect).first();
      return result || null;
    } catch (e) {
      Logger.error("DB", `getHistoryByExpect failed for ${expect}`, e);
      return null;
    }
  },

  /**
   * è·å–æœ€è¿‘çš„NæœŸå†å²è®°å½•
   */
  getRecentHistory: async (env, count = 100) => {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM lottery_history ORDER BY expect DESC LIMIT ?"
      ).bind(count).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getRecentHistory failed", e);
      return [];
    }
  },

  /**
   * æ·»åŠ å•æ¡å†å²è®°å½•
   */
  addHistory: async (env, exp, code) => {
    try {
      return await env.DB.prepare(
        "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
      ).bind(exp.toString(), code).run();
    } catch (e) {
      Logger.error("DB", `addHistory failed for ${exp}`, e);
      return null;
    }
  },

  /**
   * æ‰¹é‡æ·»åŠ å†å²è®°å½•
   */
  batchAddHistory: async (env, records) => {
    try {
      if (!records || records.length === 0) return { success: true, added: 0, skipped: 0 };
      
      const CHUNK_SIZE = 50;
      let totalAdded = 0;
      let totalSkipped = 0;

      Logger.info("DB", `å¼€å§‹æ‰¹é‡æ·»åŠ  ${records.length} æ¡è®°å½•`);

      for (let i = 0; i < records.length; i += CHUNK_SIZE) {
        const chunk = records.slice(i, i + CHUNK_SIZE);
        const batch = env.DB.batch(
          chunk.map(record =>
            env.DB.prepare(
              "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
            ).bind(record.expect.toString(), record.open_code)
          )
        );
        
        try {
          const results = await batch;
          const chunkAdded = results.reduce((sum, result) => sum + result.changes, 0);
          const chunkSkipped = chunk.length - chunkAdded;
          
          totalAdded += chunkAdded;
          totalSkipped += chunkSkipped;
          
          Logger.debug("DB", `æ‰¹æ¬¡ ${Math.floor(i/CHUNK_SIZE)+1}: æ·»åŠ  ${chunkAdded} æ¡ï¼Œè·³è¿‡ ${chunkSkipped} æ¡`);
          
          // é¿å…é€Ÿç‡é™åˆ¶
          if (i + CHUNK_SIZE < records.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        } catch (chunkError) {
          Logger.error("DB", `æ‰¹æ¬¡ ${Math.floor(i/CHUNK_SIZE)+1} æ’å…¥å¤±è´¥`, chunkError);
          
          // å¤±è´¥åå°è¯•å•æ¡æ’å…¥
          for (const record of chunk) {
            try {
              const result = await env.DB.prepare(
                "INSERT OR IGNORE INTO lottery_history (expect, open_code) VALUES (?, ?)"
              ).bind(record.expect.toString(), record.open_code).run();
              totalAdded += result.changes;
              totalSkipped += (1 - result.changes);
            } catch (singleError) {
              Logger.error("DB", `å•æ¡æ’å…¥å¤±è´¥ ${record.expect}`, singleError);
              totalSkipped++;
            }
          }
        }
      }
      
      Logger.info("DB", `æ‰¹é‡æ·»åŠ å®Œæˆ: æ€»è®¡æ·»åŠ  ${totalAdded} æ¡ï¼Œè·³è¿‡ ${totalSkipped} æ¡`);
      return { success: true, added: totalAdded, skipped: totalSkipped };
    } catch (e) {
      Logger.error("DB", "batchAddHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  /**
   * è·å–æœ€æ–°æœŸå·
   */
  getLatestExpect: async (env) => {
    try {
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect DESC LIMIT 1"
      ).first();
      return result ? result.expect : null;
    } catch (e) {
      Logger.error("DB", "getLatestExpect failed", e);
      return null;
    }
  },

  /**
   * è·å–æœ€æ—©æœŸå·
   */
  getEarliestExpect: async (env) => {
    try {
      const result = await env.DB.prepare(
        "SELECT expect FROM lottery_history ORDER BY expect ASC LIMIT 1"
      ).first();
      return result ? result.expect : null;
    } catch (e) {
      Logger.error("DB", "getEarliestExpect failed", e);
      return null;
    }
  },

  /**
   * è·å–å½“å‰ä»»åŠ¡
   */
  getTask: async (env) => {
    try {
      const r = await env.DB.prepare("SELECT data FROM lottery_tasks WHERE id = 1").first();
      return r ? JSON.parse(r.data) : null;
    } catch (e) {
      Logger.error("DB", "getTask failed", e);
      return null;
    }
  },

  /**
   * ä¿å­˜ä»»åŠ¡
   */
  saveTask: async (env, data) => {
    try {
      return await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_tasks (id, data) VALUES (1, ?)"
      ).bind(JSON.stringify(data)).run();
    } catch (e) {
      Logger.error("DB", "saveTask failed", e);
      return null;
    }
  },

  /**
   * åˆ é™¤ä»»åŠ¡
   */
  deleteTask: async (env) => {
    try {
      return await env.DB.prepare("DELETE FROM lottery_tasks WHERE id = 1").run();
    } catch (e) {
      Logger.error("DB", "deleteTask failed", e);
      return null;
    }
  },

  /**
   * å½’æ¡£é¢„æµ‹ç»“æœ
   */
  archivePrediction: async (env, expect, predData) => {
    try {
      return await env.DB.prepare(
        "INSERT OR IGNORE INTO prediction_archives (expect, prediction_json) VALUES (?, ?)"
      ).bind(expect.toString(), JSON.stringify(predData)).run();
    } catch (e) {
      Logger.error("DB", `archivePrediction failed for ${expect}`, e);
      return null;
    }
  },

  /**
   * è·å–å½’æ¡£è®°å½•
   */
  getArchives: async (env, limit = 10, offset = 0) => {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM prediction_archives WHERE result_status != 'PENDING' ORDER BY expect DESC LIMIT ? OFFSET ?"
      ).bind(limit, offset).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getArchives failed", e);
      return [];
    }
  },

  /**
   * è·å–æ‰€æœ‰å½’æ¡£è®°å½•
   */
  getAllArchives: async (env) => {
    try {
      const { results } = await env.DB.prepare(
        "SELECT * FROM prediction_archives ORDER BY expect DESC"
      ).all();
      return results || [];
    } catch (e) {
      Logger.error("DB", "getAllArchives failed", e);
      return [];
    }
  },

  /**
   * è·å–å½’æ¡£è®°å½•æ€»æ•°
   */
  getArchiveCount: async (env) => {
    try {
      const result = await env.DB.prepare(
        "SELECT COUNT(*) as count FROM prediction_archives"
      ).first();
      return result ? result.count : 0;
    } catch (e) {
      Logger.error("DB", "getArchiveCount failed", e);
      return 0;
    }
  },

  /**
   * æ›´æ–°å½’æ¡£çŠ¶æ€
   */
  updateArchiveStatus: async (env, expect, status, detail) => {
    try {
      return await env.DB.prepare(
        "UPDATE prediction_archives SET result_status = ?, hit_detail = ?, updated_at = CURRENT_TIMESTAMP WHERE expect = ?"
      ).bind(status, detail, expect.toString()).run();
    } catch (e) {
      Logger.error("DB", `updateArchiveStatus failed for ${expect}`, e);
      return null;
    }
  },

  /**
   * è·å–æŒ‡å®šæœŸå·çš„å½’æ¡£è®°å½•
   */
  getArchiveByExpect: async (env, expect) => {
    try {
      const result = await env.DB.prepare(
        "SELECT * FROM prediction_archives WHERE expect = ?"
      ).bind(expect.toString()).first();
      return result || null;
    } catch (e) {
      Logger.error("DB", `getArchiveByExpect failed for ${expect}`, e);
      return null;
    }
  },

  /**
   * è·å–è®¾ç½®
   */
  getSetting: async (env, key, def = "") => {
    try {
      const r = await env.DB.prepare(
        "SELECT value FROM lottery_settings WHERE setting_key = ?"
      ).bind(key).first();
      return r ? r.value : def;
    } catch (e) {
      Logger.error("DB", `getSetting failed for ${key}`, e);
      return def;
    }
  },

  /**
   * ä¿å­˜è®¾ç½®
   */
  saveSetting: async (env, key, val) => {
    try {
      return await env.DB.prepare(
        "INSERT OR REPLACE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
      ).bind(key, val).run();
    } catch (e) {
      Logger.error("DB", `saveSetting failed for ${key}`, e);
      return null;
    }
  },

  /**
   * è·å–æ‰€æœ‰è®¾ç½®
   */
  getAllSettings: async (env) => {
    try {
      const { results } = await env.DB.prepare(
        "SELECT setting_key, value FROM lottery_settings"
      ).all();
      const settings = {};
      results.forEach(row => {
        settings[row.setting_key] = row.value;
      });
      return settings;
    } catch (e) {
      Logger.error("DB", "getAllSettings failed", e);
      return {};
    }
  },

  /**
   * è·å–ç®—æ³•æƒé‡
   */
  getWeights: async (env) => {
    try {
      const w = await DB.getSetting(env, "ALGO_WEIGHTS", null);
      if (w) {
        const weights = JSON.parse(w);
        // ç¡®ä¿æ‰€æœ‰æƒé‡å­—æ®µéƒ½å­˜åœ¨
        return { ...CONFIG.DEFAULT_ALGO_WEIGHTS, ...weights };
      }
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    } catch (e) {
      Logger.error("DB", "getWeights failed, using default", e);
      return { ...CONFIG.DEFAULT_ALGO_WEIGHTS };
    }
  },

  /**
   * ä¿å­˜ç®—æ³•æƒé‡
   */
  saveWeights: async (env, weights) => {
    try {
      // é™åˆ¶æƒé‡èŒƒå›´
      const sanitizedWeights = {};
      Object.keys(weights).forEach(key => {
        let value = weights[key];
        value = Math.max(0.1, Math.min(5.0, value)); // é™åˆ¶åœ¨0.1-5.0ä¹‹é—´
        sanitizedWeights[key] = parseFloat(value.toFixed(2));
      });
      
      return await DB.saveSetting(env, "ALGO_WEIGHTS", JSON.stringify(sanitizedWeights));
    } catch (e) {
      Logger.error("DB", "saveWeights failed", e);
      return null;
    }
  },

  /**
   * é‡ç½®ç®—æ³•æƒé‡ä¸ºé»˜è®¤å€¼
   */
  resetWeights: async (env) => {
    try {
      return await DB.saveWeights(env, CONFIG.DEFAULT_ALGO_WEIGHTS);
    } catch (e) {
      Logger.error("DB", "resetWeights failed", e);
      return null;
    }
  },

  /**
   * æ¸…ç©ºæ‰€æœ‰æ•°æ®
   */
  clearAllHistory: async (env) => {
    try {
      const batch = [
        env.DB.prepare("DELETE FROM lottery_history"),
        env.DB.prepare("DELETE FROM prediction_archives"),
        env.DB.prepare("DELETE FROM lottery_tasks"),
        env.DB.prepare("DELETE FROM lottery_settings")
      ];
      await env.DB.batch(batch);
      return { success: true, message: "æ‰€æœ‰æ•°æ®å·²æ¸…ç©º" };
    } catch (e) {
      Logger.error("DB", "clearAllHistory failed", e);
      return { success: false, error: e.message };
    }
  },

  /**
   * è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯
   */
  getSystemStats: async (env) => {
    try {
      const [
        historyCount,
        archiveCount,
        latestExpect,
        earliestExpect,
        taskData
      ] = await Promise.all([
        DB.getHistoryCount(env),
        DB.getArchiveCount(env),
        DB.getLatestExpect(env),
        DB.getEarliestExpect(env),
        DB.getTask(env)
      ]);

      return {
        historyCount,
        archiveCount,
        latestExpect,
        earliestExpect,
        hasTask: !!taskData,
        taskStatus: taskData?.status || "æ— ä»»åŠ¡"
      };
    } catch (e) {
      Logger.error("DB", "getSystemStats failed", e);
      return null;
    }
  },

  /**
   * åˆå§‹åŒ–é»˜è®¤è®¾ç½®
   */
  initDefaultSettings: async (env) => {
    try {
      const defaultSettings = {
        "DURATION": CONFIG.SYSTEM.DEFAULT_DURATION.toString(),
        "AUTO_PUSH": "ON",
        "SCHEDULE_TIME": "OFF",
        "LAST_SCHEDULE_PUSH": "",
        "ALGO_WEIGHTS": JSON.stringify(CONFIG.DEFAULT_ALGO_WEIGHTS),
        "SYSTEM_VERSION": CONFIG.SYSTEM.VERSION,
        "LAST_SYNC": "",
        "TOTAL_SYNCS": "0",
        "TOTAL_PUSHES": "0"
      };

      const batch = Object.entries(defaultSettings).map(([key, value]) =>
        env.DB.prepare(
          "INSERT OR IGNORE INTO lottery_settings (setting_key, value) VALUES (?, ?)"
        ).bind(key, value)
      );

      await env.DB.batch(batch);
      Logger.info("DB", "é»˜è®¤è®¾ç½®åˆå§‹åŒ–å®Œæˆ");
      return true;
    } catch (e) {
      Logger.error("DB", "initDefaultSettings failed", e);
      return false;
    }
  }
};

// ==============================================================================
// 4. æ•°å­¦ä¸ç»Ÿè®¡åˆ†æå¼•æ“ (Mathematical & Statistical Engine) - å®Œæ•´ç‰ˆ
// ==============================================================================

class MathEngine {
  /**
   * åŸºç¡€æ•°æ®ç»Ÿè®¡
   */
  static analyzeBasicStats(history) {
    if (!history || history.length === 0) {
      return {
        zodiacCounts: {},
        colorCounts: { red: 0, blue: 0, green: 0 },
        headCounts: { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 },
        tailCounts: {},
        numberCounts: {},
        totalRecords: 0,
        lastSpecial: null,
        lastZodiac: null,
        lastColor: null
      };
    }

    const zodiacCounts = {};
    const colorCounts = { red: 0, blue: 0, green: 0 };
    const headCounts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
    const tailCounts = {};
    const numberCounts = {};

    // åˆå§‹åŒ–
    for (const z in CONFIG.ZODIAC_MAP) zodiacCounts[z] = 0;
    for (let i = 0; i <= 9; i++) tailCounts[i] = 0;
    for (let i = 1; i <= 49; i++) numberCounts[i] = 0;

    let lastSpecial = null;
    let lastZodiac = null;
    let lastColor = null;

    history.forEach(record => {
      const special = parseInt(record.open_code.split(",")[6]);
      const attr = Formatter.getAttributes(special);

      // ç”Ÿè‚–ç»Ÿè®¡
      zodiacCounts[attr.zodiac]++;
      // æ³¢è‰²ç»Ÿè®¡
      colorCounts[attr.color]++;
      // å¤´æ•°ç»Ÿè®¡
      const head = Math.floor(special / 10);
      if (head >= 0 && head <= 4) headCounts[head]++;
      // å°¾æ•°ç»Ÿè®¡
      tailCounts[special % 10]++;
      // å·ç ç»Ÿè®¡
      numberCounts[special]++;

      // è®°å½•æœ€åä¸€æœŸ
      if (lastSpecial === null) {
        lastSpecial = special;
        lastZodiac = attr.zodiac;
        lastColor = attr.color;
      }
    });

    return {
      zodiacCounts,
      colorCounts,
      headCounts,
      tailCounts,
      numberCounts,
      totalRecords: history.length,
      lastSpecial,
      lastZodiac,
      lastColor
    };
  }

  /**
   * é«˜çº§ç¡®å®šæ€§åˆ†æ (æ ¸å¿ƒç®—æ³•)
   */
  static analyzeDeterminants(history) {
    if (!history || history.length < 10) {
      return {
        transitionMatrix: {},
        omission: {},
        tailMatrix: {},
        zodiacContinuity: {},
        colorContinuity: {}
      };
    }

    const analysis = {
      transitionMatrix: {}, // ç”Ÿè‚–è½¬ç§»çŸ©é˜µ
      omission: {},         // å½“å‰é—æ¼å€¼
      tailMatrix: {},       // å°¾æ•°è½¬ç§»çŸ©é˜µ
      zodiacContinuity: {}, // ç”Ÿè‚–è¿ç»­æ€§ç»Ÿè®¡
      colorContinuity: {}   // æ³¢è‰²è¿ç»­æ€§ç»Ÿè®¡
    };

    // åˆå§‹åŒ–ç»“æ„
    Object.keys(CONFIG.ZODIAC_MAP).forEach(z => {
      analysis.transitionMatrix[z] = {};
      analysis.omission[z] = 0;
      analysis.zodiacContinuity[z] = { single: 0, double: 0, triple: 0, more: 0 };
    });
    
    for (let i = 0; i < 10; i++) {
      analysis.tailMatrix[i] = {};
    }
    
    ['red', 'blue', 'green'].forEach(c => {
      analysis.colorContinuity[c] = { single: 0, double: 0, triple: 0, more: 0 };
    });

    // 1. è®¡ç®—å½“å‰é—æ¼å€¼
    const currentOmission = {};
    Object.keys(CONFIG.ZODIAC_MAP).forEach(z => currentOmission[z] = 0);

    for (let i = 0; i < history.length; i++) {
      const special = parseInt(history[i].open_code.split(",")[6]);
      const z = Formatter.getAttributes(special).zodiac;

      Object.keys(currentOmission).forEach(key => {
        if (currentOmission[key] !== -1) {
          if (key === z) currentOmission[key] = -1;
          else currentOmission[key]++;
        }
      });
    }

    Object.keys(currentOmission).forEach(key => {
      analysis.omission[key] = currentOmission[key] === -1 ? 0 : currentOmission[key];
    });

    // 2. æ„å»ºé©¬å°”å¯å¤«é“¾å’Œè¿ç»­æ€§ç»Ÿè®¡
    let currentZodiacStreak = 0;
    let currentZodiac = null;
    let currentColorStreak = 0;
    let currentColor = null;

    for (let i = history.length - 2; i >= 0; i--) {
      const prevRecord = history[i + 1];
      const currRecord = history[i];

      const prevSpecial = parseInt(prevRecord.open_code.split(",")[6]);
      const currSpecial = parseInt(currRecord.open_code.split(",")[6]);

      const prevZodiac = Formatter.getAttributes(prevSpecial).zodiac;
      const currZodiac = Formatter.getAttributes(currSpecial).zodiac;

      const prevColor = Formatter.getAttributes(prevSpecial).color;
      const currColor = Formatter.getAttributes(currSpecial).color;

      const prevTail = prevSpecial % 10;
      const currTail = currSpecial % 10;

      // å¡«å……ç”Ÿè‚–è½¬ç§»çŸ©é˜µ
      if (!analysis.transitionMatrix[prevZodiac][currZodiac]) {
        analysis.transitionMatrix[prevZodiac][currZodiac] = 0;
      }
      analysis.transitionMatrix[prevZodiac][currZodiac]++;

      // å¡«å……å°¾æ•°è½¬ç§»çŸ©é˜µ
      if (!analysis.tailMatrix[prevTail][currTail]) {
        analysis.tailMatrix[prevTail][currTail] = 0;
      }
      analysis.tailMatrix[prevTail][currTail]++;

      // ç»Ÿè®¡è¿ç»­æ€§
      // ç”Ÿè‚–è¿ç»­æ€§
      if (prevZodiac === currZodiac) {
        if (currentZodiac !== prevZodiac) {
          currentZodiac = prevZodiac;
          currentZodiacStreak = 2;
        } else {
          currentZodiacStreak++;
        }
      } else {
        if (currentZodiacStreak > 0) {
          const z = currentZodiac;
          if (currentZodiacStreak === 2) analysis.zodiacContinuity[z].double++;
          else if (currentZodiacStreak === 3) analysis.zodiacContinuity[z].triple++;
          else if (currentZodiacStreak > 3) analysis.zodiacContinuity[z].more++;
          currentZodiacStreak = 0;
          currentZodiac = null;
        }
      }

      // æ³¢è‰²è¿ç»­æ€§
      if (prevColor === currColor) {
        if (currentColor !== prevColor) {
          currentColor = prevColor;
          currentColorStreak = 2;
        } else {
          currentColorStreak++;
        }
      } else {
        if (currentColorStreak > 0) {
          const c = currentColor;
          if (currentColorStreak === 2) analysis.colorContinuity[c].double++;
          else if (currentColorStreak === 3) analysis.colorContinuity[c].triple++;
          else if (currentColorStreak > 3) analysis.colorContinuity[c].more++;
          currentColorStreak = 0;
          currentColor = null;
        }
      }
    }

    // å¤„ç†æœ€åçš„è¿ç»­
    if (currentZodiacStreak > 0) {
      const z = currentZodiac;
      if (currentZodiacStreak === 2) analysis.zodiacContinuity[z].double++;
      else if (currentZodiacStreak === 3) analysis.zodiacContinuity[z].triple++;
      else if (currentZodiacStreak > 3) analysis.zodiacContinuity[z].more++;
    }

    if (currentColorStreak > 0) {
      const c = currentColor;
      if (currentColorStreak === 2) analysis.colorContinuity[c].double++;
      else if (currentColorStreak === 3) analysis.colorContinuity[c].triple++;
      else if (currentColorStreak > 3) analysis.colorContinuity[c].more++;
    }

    // 3. è®¡ç®—å•æ¬¡å‡ºç°çš„æ¬¡æ•°
    Object.keys(analysis.zodiacContinuity).forEach(z => {
      const total = (analysis.zodiacContinuity[z].double || 0) + 
                   (analysis.zodiacContinuity[z].triple || 0) + 
                   (analysis.zodiacContinuity[z].more || 0);
      const singleCount = (analysis.omission[z] === 0 ? 1 : 0); // ç®€åŒ–è®¡ç®—
      analysis.zodiacContinuity[z].single = Math.max(0, history.length - total - singleCount);
    });

    return analysis;
  }

  /**
   * è®¡ç®—å·ç çš„å†·çƒ­çŠ¶æ€
   */
  static calculateHotColdStatus(history, windowSize = 20) {
    if (!history || history.length === 0) return { hotNumbers: [], warmNumbers: [], coldNumbers: [] };
    
    const recentWindow = Math.min(windowSize, history.length);
    const recentHistory = history.slice(0, recentWindow);
    const allHistory = history;
    
    const recentCounts = {};
    const totalCounts = {};
    
    // åˆå§‹åŒ–
    for (let i = 1; i <= 49; i++) {
      recentCounts[i] = 0;
      totalCounts[i] = 0;
    }
    
    // ç»Ÿè®¡
    allHistory.forEach(record => {
      const numbers = record.open_code.split(",").map(n => parseInt(n));
      const special = numbers[6];
      totalCounts[special]++;
    });
    
    recentHistory.forEach(record => {
      const numbers = record.open_code.split(",").map(n => parseInt(n));
      const special = numbers[6];
      recentCounts[special]++;
    });
    
    // è®¡ç®—çƒ­åº¦åˆ†æ•°
    const heatScores = {};
    for (let i = 1; i <= 49; i++) {
      const recentFreq = recentCounts[i];
      const totalFreq = totalCounts[i];
      const avgFreq = totalFreq / allHistory.length;
      
      // çƒ­åº¦åˆ†æ•° = è¿‘æœŸé¢‘ç‡ * 3 + æ€»é¢‘ç‡ * 1
      const heatScore = (recentFreq * 3) + (totalFreq * 1);
      heatScores[i] = heatScore;
    }
    
    // åˆ†ç±»
    const scores = Object.values(heatScores);
    const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    
    const hotNumbers = [];
    const warmNumbers = [];
    const coldNumbers = [];
    
    for (let i = 1; i <= 49; i++) {
      if (heatScores[i] > avgScore * 1.5) hotNumbers.push(i);
      else if (heatScores[i] > avgScore * 0.5) warmNumbers.push(i);
      else coldNumbers.push(i);
    }
    
    return { hotNumbers, warmNumbers, coldNumbers };
  }

  /**
   * è®¡ç®—é—æ¼å€¼å›å½’é¢„æµ‹
   */
  static calculateOmissionPrediction(omissionData) {
    const predictions = {};
    
    Object.entries(omissionData).forEach(([zodiac, omission]) => {
      let score = 0;
      
      if (omission === 0) {
        // åˆšå¼€è¿‡ï¼Œå¯èƒ½ä¸ä¼šè¿ç»­å¼€
        score = -30;
      } else if (omission <= 3) {
        // è¾ƒçƒ­ï¼Œå¯èƒ½å›è¡¥
        score = 10 + omission * 2;
      } else if (omission <= 10) {
        // æ¸©å·ï¼Œæ­£å¸¸é—æ¼
        score = 20 + omission * 1.5;
      } else if (omission <= 20) {
        // å†·å·ï¼Œå¯èƒ½åå¼¹
        score = 30 + omission * 1.2;
      } else {
        // æå†·å·ï¼Œå¼ºçƒˆåå¼¹é¢„æœŸ
        score = 50 + omission * 1.0;
      }
      
      predictions[zodiac] = score;
    });
    
    return predictions;
  }
}

// ==============================================================================
// 5. æ™ºèƒ½é¢„æµ‹ç”Ÿæˆå™¨ (Intelligent Prediction Generator) - å®Œæ•´ç‰ˆ
// ==============================================================================

class PredictionEngine {
  /**
   * ç”Ÿæˆé¢„æµ‹ç»“æœ
   */
  static generate(task, historicalAnalysis, weights, determinants = null) {
    const history = task.history || [];

    // å…œåº•é€»è¾‘ï¼šæ— å†å²æ•°æ®
    if (!history || history.length === 0) {
      return this.generateStaticFallback(task);
    }

    // è·å–ä¸Šä¸€æœŸæ•°æ®ä½œä¸ºé”šç‚¹
    const lastRecord = history[0];
    const lastSpecial = parseInt(lastRecord.open_code.split(",")[6]);
    const lastAttr = Formatter.getAttributes(lastSpecial);
    const lastZodiac = lastAttr.zodiac;
    const lastColor = lastAttr.color;
    const lastTail = lastSpecial % 10;
    const lastHead = Math.floor(lastSpecial / 10);

    // æ‰§è¡Œæ·±åº¦ç¡®å®šæ€§åˆ†æï¼ˆå¦‚æœæœªæä¾›ï¼‰
    if (!determinants) {
      determinants = MathEngine.analyzeDeterminants(history);
    }
    
    const { zodiacCounts, colorCounts, headCounts, tailCounts, numberCounts } = historicalAnalysis;

    // ä½¿ç”¨ä¼ å…¥çš„æƒé‡ï¼Œæˆ–å›é€€åˆ°é»˜è®¤
    const W = weights || CONFIG.DEFAULT_ALGO_WEIGHTS;

    // ----------------------------------------------------
    // ç»´åº¦ä¸€ï¼šç”Ÿè‚–è¯„åˆ†ç³»ç»Ÿ (Multi-Factor Scoring)
    // ----------------------------------------------------
    const zodiacScores = {};

    Object.keys(CONFIG.ZODIAC_MAP).forEach(zodiac => {
      let score = 0;

      // 1. åŸºç¡€é¢‘ç‡åˆ† (Frequency Score)
      const freq = zodiacCounts[zodiac] || 0;
      const freqScore = (freq / history.length) * 100;
      score += freqScore * W.w_freq;

      // 2. é©¬å°”å¯å¤«è½¬ç§»åˆ† (Markov Transition Score)
      const transitions = determinants.transitionMatrix[lastZodiac] || {};
      const transitionCount = transitions[zodiac] || 0;
      const totalTransitions = Object.values(transitions).reduce((a, b) => a + b, 0) || 1;
      const prob = transitionCount / totalTransitions;
      score += prob * 250 * W.w_markov;

      // 3. é—æ¼å€¼å›å½’åˆ† (Omission Regression Score)
      const omission = determinants.omission[zodiac] || 0;
      let omissionScore = 0;
      
      if (omission === 0) {
        // è¿å¼€æƒ©ç½šï¼Œä½†è€ƒè™‘å¯èƒ½çš„çƒ­å·è¶‹åŠ¿
        const continuity = determinants.zodiacContinuity[zodiac] || { single: 0, double: 0, triple: 0, more: 0 };
        const totalContinuity = continuity.double + continuity.triple * 2 + continuity.more * 3;
        
        if (totalContinuity > 3) {
          // è¿™ä¸ªç”Ÿè‚–æœ‰è¿å¼€å†å²ï¼Œå¯èƒ½ç»§ç»­çƒ­
          omissionScore = 10;
        } else {
          // æ­£å¸¸è¿å¼€æƒ©ç½š
          omissionScore = -30;
        }
      } else if (omission <= 3) {
        omissionScore = 10 + omission * 3; // è¾ƒçƒ­å›è¡¥
      } else if (omission <= 10) {
        omissionScore = 20 + omission * 2; // æ¸©å·æ­£å¸¸é—æ¼
      } else if (omission <= 20) {
        omissionScore = 30 + omission * 1.5; // å†·å·åå¼¹é¢„æœŸ
      } else {
        omissionScore = 50 + omission * 1.0; // æå†·å¼ºçƒˆåå¼¹
      }
      
      score += omissionScore * W.w_omission;

      // 4. ç”Ÿè‚–å…³ç³»åŠ åˆ† (Relation Score)
      let relationScore = 0;
      
      // å…­åˆå…³ç³» (å¼ºå…³è”)
      if (CONFIG.RELATIONS.LIU_HE[lastZodiac] === zodiac) {
        relationScore += 25;
      }
      
      // ä¸‰åˆå…³ç³» (æ¬¡å¼ºå…³è”)
      if (CONFIG.RELATIONS.SAN_HE[lastZodiac]?.includes(zodiac)) {
        relationScore += 15;
      }
      
      // ç›¸å†²å…³ç³» (åå‘å…³è”ï¼Œæœ‰æ—¶ä¹Ÿä¼šå‡ºç°)
      if (CONFIG.RELATIONS.CHONG[lastZodiac] === zodiac) {
        relationScore += 5; // å¼±å…³è”ï¼Œä½œä¸ºå‚è€ƒ
      }
      
      score += relationScore * W.w_relation;

      // 5. è¿ç»­æ€§æ¨¡å¼è¯†åˆ«
      const continuity = determinants.zodiacContinuity[zodiac] || { single: 0, double: 0, triple: 0, more: 0 };
      const continuityPatternScore = continuity.double * 5 + continuity.triple * 8 + continuity.more * 10;
      score += continuityPatternScore * 0.1;

      zodiacScores[zodiac] = score;
    });

    // æ’åºç”Ÿè‚–
    const sortedZodiacs = Object.entries(zodiacScores)
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);

    const mainZodiacs = sortedZodiacs.slice(0, 3);
    const guardZodiacs = sortedZodiacs.slice(3, 6);

    // ----------------------------------------------------
    // ç»´åº¦äºŒï¼šæ³¢è‰²åˆ†æ (Color Analysis)
    // ----------------------------------------------------
    const colorScores = {};
    ['red', 'blue', 'green'].forEach(color => {
      const count = colorCounts[color] || 0;
      const ratio = count / history.length;
      
      // ç†è®ºæ¦‚ç‡
      let ideal = 0;
      if (color === 'red') ideal = CONFIG.COLORS.red.length / 49;
      else if (color === 'blue') ideal = CONFIG.COLORS.blue.length / 49;
      else ideal = CONFIG.COLORS.green.length / 49;
      
      // å‡å€¼å›å½’åˆ†æ•°ï¼šåç¦»è¶Šå¤§ï¼Œå›å½’åŠ¨åŠ›è¶Šå¼º
      let regressionScore = (ideal - ratio) * 200;
      
      // è¿‘æœŸçƒ­åº¦ä¿®æ­£
      let recentHits = 0;
      for (let i = 0; i < Math.min(10, history.length); i++) {
        const special = parseInt(history[i].open_code.split(",")[6]);
        if (Formatter.getAttributes(special).color === color) recentHits++;
      }
      
      // è¿ç»­æ€§åˆ†æ
      const continuity = determinants.colorContinuity[color] || { single: 0, double: 0, triple: 0, more: 0 };
      const continuityScore = continuity.double * 3 + continuity.triple * 5 + continuity.more * 8;
      
      // ç»¼åˆåˆ†æ•°
      let score = regressionScore;
      
      if (color === lastColor) {
        // åˆšå¼€è¿‡ï¼Œå¯èƒ½ä¸ä¼šè¿ç»­
        if (recentHits > 3) score -= 40; // å¤ªçƒ­é™æ¸©
        else score += continuityScore * 2; // æœ‰ä¸€å®šè¿ç»­æ€§
      } else {
        // ä¸åŒé¢œè‰²ï¼Œæœ‰æœºä¼š
        if (recentHits < 2) score += 20; // å†·è‰²å‡æ¸©
      }
      
      // åº”ç”¨æƒé‡
      colorScores[color] = score * W.w_color;
    });

    const sortedColors = Object.entries(colorScores)
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);

    // ----------------------------------------------------
    // ç»´åº¦ä¸‰ï¼šå°¾æ•°ä¸å¤´æ•° (Tail & Head)
    // ----------------------------------------------------
    // å°¾æ•°åˆ†æ
    const tailScores = {};
    for (let i = 0; i < 10; i++) {
      const count = tailCounts[i] || 0;
      const ratio = count / history.length;
      const ideal = 0.1; // æ¯ä¸ªå°¾æ•°ç†è®ºæ¦‚ç‡
      
      // è½¬ç§»æ¦‚ç‡
      const transitions = determinants.tailMatrix[lastTail] || {};
      const transitionCount = transitions[i] || 0;
      const totalTransitions = Object.values(transitions).reduce((a, b) => a + b, 0) || 1;
      const transitionProb = transitionCount / totalTransitions;
      
      // å‡å€¼å›å½’ + è½¬ç§»æ¦‚ç‡
      let score = (ideal - ratio) * 100 + transitionProb * 50;
      
      // è¿‘æœŸçƒ­åº¦
      let recentHits = 0;
      for (let j = 0; j < Math.min(10, history.length); j++) {
        const special = parseInt(history[j].open_code.split(",")[6]);
        if (special % 10 === i) recentHits++;
      }
      
      if (i === lastTail) {
        if (recentHits > 2) score -= 30; // è¿‡çƒ­é™æ¸©
        else score += 10; // å¯èƒ½è¿å°¾
      }
      
      tailScores[i] = score;
    }
    
    const sortedTails = Object.entries(tailScores)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(entry => parseInt(entry[0]));

    // å¤´æ•°åˆ†æ
    const headScores = {};
    for (let i = 0; i <= 4; i++) {
      const count = headCounts[i] || 0;
      const ratio = count / history.length;
      
      // ç†è®ºæ¦‚ç‡
      let ideal = 0;
      if (i === 0) ideal = 9 / 49;    // 0å¤´æœ‰9ä¸ªå·ç 
      else if (i === 1) ideal = 10 / 49; // 1å¤´æœ‰10ä¸ªå·ç 
      else if (i === 2) ideal = 10 / 49; // 2å¤´æœ‰10ä¸ªå·ç 
      else if (i === 3) ideal = 10 / 49; // 3å¤´æœ‰10ä¸ªå·ç 
      else ideal = 10 / 49;              // 4å¤´æœ‰10ä¸ªå·ç 
      
      let score = (ideal - ratio) * 100;
      
      if (i === lastHead) {
        // åˆšå¼€è¿‡è¿™ä¸ªå¤´æ•°
        let recentSameHead = 0;
        for (let j = 0; j < Math.min(5, history.length); j++) {
          const special = parseInt(history[j].open_code.split(",")[6]);
          if (Math.floor(special / 10) === i) recentSameHead++;
        }
        
        if (recentSameHead > 2) score -= 20; // è¿‡çƒ­
        else score += 5; // å¯èƒ½å»¶ç»­
      }
      
      headScores[i] = score;
    }
    
    const sortedHeads = Object.entries(headScores)
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);

    // ----------------------------------------------------
    // ç»´åº¦å››ï¼šå·ç é€‰å–ä¸å½¢æ€åˆ†æ
    // ----------------------------------------------------
    const bestZodiac = mainZodiacs[0];
    const bestColor = sortedColors[0];
    const bestHead = parseInt(sortedHeads[0]);
    const bestTails = sortedTails.slice(0, 3);
    
    // å€™é€‰å·ç ï¼šç¬¦åˆæœ€ä½³ç”Ÿè‚–ã€æ³¢è‰²ã€å¤´å°¾
    let candidates = CONFIG.ZODIAC_MAP[bestZodiac].filter(num => {
      const attr = Formatter.getAttributes(num);
      const head = Math.floor(num / 10);
      const tail = num % 10;
      
      // åŸºç¡€åŒ¹é…
      const matchesColor = attr.color === bestColor;
      const matchesHead = head === bestHead;
      const matchesTail = bestTails.includes(tail);
      
      // è®¡åˆ†
      let score = 0;
      if (matchesColor) score += 3;
      if (matchesHead) score += 2;
      if (matchesTail) score += 1;
      
      return score >= 2; // è‡³å°‘åŒ¹é…2ä¸ªæ¡ä»¶
    });
    
    // å¦‚æœæ²¡æœ‰è¶³å¤Ÿå€™é€‰ï¼Œæ”¾å®½æ¡ä»¶
    if (candidates.length === 0) {
      candidates = CONFIG.ZODIAC_MAP[bestZodiac].filter(num => {
        const attr = Formatter.getAttributes(num);
        return attr.color === bestColor;
      });
    }
    
    // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œå–ç”Ÿè‚–çš„ç¬¬ä¸€ä¸ªå·ç 
    if (candidates.length === 0) {
      candidates = [CONFIG.ZODIAC_MAP[bestZodiac][0]];
    }
    
    // ä»å€™é€‰å·ç ä¸­é€‰æ‹©ä¸€ä¸ªï¼ˆåŸºäºå†å²é¢‘ç‡ï¼‰
    let bestNumber = candidates[0];
    let maxFreq = numberCounts[bestNumber] || 0;
    
    candidates.forEach(num => {
      const freq = numberCounts[num] || 0;
      if (freq > maxFreq) {
        maxFreq = freq;
        bestNumber = num;
      }
    });
    
    // å½¢æ€åˆ¤æ–­
    const isBig = bestNumber >= 25;
    const isOdd = bestNumber % 2 !== 0;
    const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
    
    // è®¡ç®—ç½®ä¿¡åº¦
    const topScore = zodiacScores[mainZodiacs[0]];
    const secondScore = zodiacScores[mainZodiacs[1]];
    const scoreGap = topScore - secondScore;
    
    let confidence = 50; // åŸºç¡€ç½®ä¿¡åº¦
    
    // åŸºäºæ•°æ®é‡
    confidence += Math.min(20, history.length / 10);
    
    // åŸºäºåˆ†æ•°å·®è·
    confidence += Math.min(20, scoreGap / 10);
    
    // åŸºäºå¤šä¸ªç»´åº¦çš„ä¸€è‡´æ€§
    const consistencyBonus = (mainZodiacs.includes(bestZodiac) ? 5 : 0) +
                           (sortedColors[0] === bestColor ? 5 : 0) +
                           (sortedHeads[0] == bestHead ? 3 : 0);
    
    confidence += consistencyBonus;
    
    // é™åˆ¶èŒƒå›´
    confidence = Math.max(30, Math.min(95, confidence));

    return {
      nextExpect: task.expect,
      zodiac: {
        main: mainZodiacs,
        guard: guardZodiacs,
        scores: zodiacScores
      },
      color: {
        main: bestColor,
        guard: sortedColors[1],
        scores: colorScores
      },
      head: {
        main: `${bestHead}å¤´`,
        guard: `${sortedHeads[1]}å¤´`,
        scores: headScores
      },
      tail: bestTails,
      tailScores: tailScores,
      shape: shape,
      exampleNumber: bestNumber,
      exampleZodiac: bestZodiac,
      exampleColor: Formatter.getAttributes(bestNumber).color,
      confidence: Math.floor(confidence),
      analysisBased: true,
      totalHistoryRecords: history.length,
      usedWeights: W,
      generatedAt: new Date().toISOString(),
      algorithmVersion: "V5.0"
    };
  }

  /**
   * é™æ€å…œåº•é¢„æµ‹ (æ— æ•°æ®æ—¶ä½¿ç”¨)
   */
  static generateStaticFallback(task) {
    const date = new Date();
    const day = date.getDate();
    const hour = date.getHours();
    
    // åŸºäºæ—¥æœŸå’Œæ—¶é—´çš„ç¡®å®šæ€§é€‰æ‹©
    const allZodiacs = Object.keys(CONFIG.ZODIAC_MAP);
    const colors = ['red', 'blue', 'green'];
    
    const zodiacIndex = (day * hour) % allZodiacs.length;
    const colorIndex = (day + hour) % colors.length;
    
    const mainZodiac = allZodiacs[zodiacIndex];
    const mainColor = colors[colorIndex];
    
    // ä»ç”Ÿè‚–ä¸­é€‰ä¸€ä¸ªå·ç 
    const candidates = CONFIG.ZODIAC_MAP[mainZodiac];
    const numIndex = hour % candidates.length;
    const exampleNumber = candidates[numIndex];
    
    // å½¢æ€åˆ¤æ–­
    const isBig = exampleNumber >= 25;
    const isOdd = exampleNumber % 2 !== 0;
    const shape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
    
    return {
      nextExpect: task.expect,
      zodiac: {
        main: [mainZodiac, allZodiacs[(zodiacIndex + 3) % allZodiacs.length], allZodiacs[(zodiacIndex + 6) % allZodiacs.length]],
        guard: [allZodiacs[(zodiacIndex + 1) % allZodiacs.length], allZodiacs[(zodiacIndex + 4) % allZodiacs.length], allZodiacs[(zodiacIndex + 8) % allZodiacs.length]],
        scores: {}
      },
      color: {
        main: mainColor,
        guard: colors[(colorIndex + 1) % colors.length],
        scores: {}
      },
      head: {
        main: "2å¤´",
        guard: "4å¤´",
        scores: {}
      },
      tail: [1, 5, 9],
      tailScores: {},
      shape: shape,
      exampleNumber: exampleNumber,
      exampleZodiac: mainZodiac,
      exampleColor: Formatter.getAttributes(exampleNumber).color,
      confidence: 20,
      analysisBased: false,
      totalHistoryRecords: 0,
      usedWeights: CONFIG.DEFAULT_ALGO_WEIGHTS,
      generatedAt: new Date().toISOString(),
      algorithmVersion: "V5.0-Static"
    };
  }

  /**
   * æ‰¹é‡ç”Ÿæˆå†å²å¤ç›˜é¢„æµ‹
   */
  static async generateBacktestPrediction(env, targetExpect, historyUpToTarget) {
    const mockTask = {
      expect: targetExpect,
      history: historyUpToTarget,
      startTime: Date.now(),
      unlockTime: Date.now() + CONFIG.SYSTEM.DEFAULT_DURATION,
      status: "CALCULATING"
    };
    
    const historicalAnalysis = MathEngine.analyzeBasicStats(historyUpToTarget);
    const weights = await DB.getWeights(env);
    
    return this.generate(mockTask, historicalAnalysis, weights);
  }

  /**
   * è¯„ä¼°é¢„æµ‹å‡†ç¡®æ€§
   */
  static evaluatePrediction(prediction, actualNumber) {
    const actualAttr = Formatter.getAttributes(actualNumber);
    
    const results = {
      zodiacHit: {
        main: prediction.zodiac.main.includes(actualAttr.zodiac),
        guard: prediction.zodiac.guard.includes(actualAttr.zodiac)
      },
      colorHit: {
        main: prediction.color.main === actualAttr.color,
        guard: prediction.color.guard === actualAttr.color
      },
      tailHit: prediction.tail.includes(actualNumber % 10),
      headHit: parseInt(prediction.head.main) === Math.floor(actualNumber / 10),
      shapeHit: this.checkShapeHit(prediction.shape, actualNumber),
      numberHit: prediction.exampleNumber === actualNumber
    };
    
    // è®¡ç®—æ€»åˆ† (0-100)
    let score = 0;
    if (results.zodiacHit.main) score += 40;
    else if (results.zodiacHit.guard) score += 20;
    
    if (results.colorHit.main) score += 20;
    else if (results.colorHit.guard) score += 10;
    
    if (results.tailHit) score += 15;
    if (results.headHit) score += 10;
    if (results.shapeHit) score += 5;
    if (results.numberHit) score += 10;
    
    results.totalScore = score;
    results.grade = this.getGrade(score);
    
    return results;
  }

  /**
   * æ£€æŸ¥å½¢æ€æ˜¯å¦å‘½ä¸­
   */
  static checkShapeHit(predictedShape, actualNumber) {
    const isBig = actualNumber >= 25;
    const isOdd = actualNumber % 2 !== 0;
    const actualShape = (isBig ? "å¤§" : "å°") + (isOdd ? "å•" : "åŒ");
    return predictedShape === actualShape;
  }

  /**
   * æ ¹æ®åˆ†æ•°è·å–ç­‰çº§
   */
  static getGrade(score) {
    if (score >= 80) return "S";
    if (score >= 70) return "A";
    if (score >= 60) return "B";
    if (score >= 50) return "C";
    if (score >= 40) return "D";
    return "F";
  }
}

// ==============================================================================
// 6. æ¶ˆæ¯æ¸²æŸ“å™¨ (UI Renderer) - å®Œæ•´ç‰ˆ
// ==============================================================================

class MessageRenderer {
  /**
   * æ¸²æŸ“é¢„æµ‹é¢„è§ˆæ¶ˆæ¯
   */
  static renderPreview(prediction, task = null, includeRefresh = false, weights = null) {
    const refreshButton = includeRefresh ? `\n\nğŸ”„ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ·æ–°é¢„æµ‹` : '';
    
    // æ•°æ®æ¥æºè¯´æ˜
    let dataSource = "";
    if (prediction.analysisBased) {
      dataSource = `ğŸ“Š åŸºäº ${prediction.totalHistoryRecords} æœŸå†å²æ•°æ®æ·±åº¦åˆ†æ`;
    } else {
      dataSource = `âš ï¸ æ— å†å²æ•°æ®ï¼ŒåŸºäºé™æ€ç®—æ³•ç”Ÿæˆ`;
    }
    
    // æƒé‡ä¿¡æ¯
    let weightInfo = "";
    if (weights && prediction.analysisBased) {
      const w = prediction.usedWeights || weights;
      weightInfo = `\nâš™ï¸ <b>åŠ¨æ€æƒé‡å‚æ•°</b>\n` +
        `é©¬å°”å¯å¤«: ${w.w_markov.toFixed(1)} | é—æ¼: ${w.w_omission.toFixed(1)}\n` +
        `é¢‘ç‡: ${w.w_freq.toFixed(1)} | å…³ç³»: ${w.w_relation.toFixed(1)}\n` +
        `æ³¢è‰²: ${w.w_color.toFixed(1)} | å°¾æ•°: ${w.w_tail.toFixed(1)}`;
    }
    
    // è¿›åº¦ä¿¡æ¯
    let progressInfo = '';
    if (task) {
      if (task.status === "CALCULATING") {
        const percent = task.targetSims > 0 ? 
          Math.min(100, ((task.currentSims / task.targetSims) * 100).toFixed(0)) : 0;
        const progressBar = Formatter.generateProgressBar(task.currentSims, task.targetSims);
        
        const timeLeft = Math.max(0, task.unlockTime - Date.now());
        const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
        const minutesLeft = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        
        progressInfo = `\nâ³ <b>é¢„æµ‹ç”Ÿæˆä¸­...</b>\n` +
          `${progressBar} ${percent}%\n` +
          `å‰©ä½™: ${hoursLeft}æ—¶ ${minutesLeft}åˆ†`;
      } else if (task.status === "DONE") {
        const sentStatus = task.isSent ? "âœ… å·²æ¨é€" : "ğŸ”„ å¾…æ¨é€";
        progressInfo = `\nâœ… <b>é¢„æµ‹å·²å®Œæˆ</b>\n${sentStatus}`;
      }
    }
    
    // ä¸»è¦é¢„æµ‹å†…å®¹
    const mainContent = `
<b>ğŸ”® ${CONFIG.SYSTEM.NAME} - æ™ºèƒ½é¢„æµ‹</b>
ç¬¬ <b>${prediction.nextExpect}</b> æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${dataSource}${progressInfo}${weightInfo}

ğŸ­ <b>ç”Ÿè‚–æ¨è</b>
${CONFIG.EMOJI.fire} ä¸»æ¨: [ ${prediction.zodiac.main.join(" ")} ]
${CONFIG.EMOJI.shield} é˜²å®ˆ: [ ${prediction.zodiac.guard.join(" ")} ]

ğŸ¨ <b>æ³¢è‰²å‚è€ƒ</b>
ä¸»${CONFIG.EMOJI[prediction.color.main]} / é˜²${CONFIG.EMOJI[prediction.color.guard]}

ğŸ”¢ <b>ç‰¹ç å›´çŒ</b>
å¤´æ•°: ${prediction.head.main} | å°¾æ•°: [ ${prediction.tail.join(", ")} ]
å½¢æ€: ${prediction.shape}

ğŸ“Š <b>é‡‘èƒ†ç¤ºä¾‹</b>: ${prediction.exampleNumber} (${prediction.exampleZodiac}/${CONFIG.EMOJI[prediction.exampleColor]})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${CONFIG.EMOJI.bot} <b>ç®—æ³•ç‰ˆæœ¬</b>: ${prediction.algorithmVersion}
<b>ç½®ä¿¡åº¦</b>: ${prediction.confidence}%
<b>ç”Ÿæˆæ—¶é—´</b>: ${new Date(prediction.generatedAt).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
${refreshButton}
    `.trim();

    if (includeRefresh) {
      return {
        text: mainContent,
        keyboard: {
          inline_keyboard: [[
            { text: `${CONFIG.EMOJI.sync} åˆ·æ–°é¢„æµ‹ç»“æœ`, callback_data: "refresh_preview" },
            { text: `${CONFIG.EMOJI.chart} æŸ¥çœ‹è¯¦æƒ…`, callback_data: "view_details" }
          ]]
        }
      };
    }

    return { text: mainContent, keyboard: null };
  }

  /**
   * æ¸²æŸ“è¯¦ç»†é¢„æµ‹ä¿¡æ¯
   */
  static renderPredictionDetails(prediction) {
    // ç”Ÿè‚–åˆ†æ•°è¯¦æƒ…
    let zodiacDetails = "<b>ğŸ­ ç”Ÿè‚–è¯„åˆ†è¯¦æƒ…:</b>\n";
    const sortedZodiacScores = Object.entries(prediction.zodiac.scores || {})
      .sort((a, b) => b[1] - a[1])
      .slice(0, 8);
    
    sortedZodiacScores.forEach(([zodiac, score], index) => {
      const rank = index + 1;
      const isMain = prediction.zodiac.main.includes(zodiac);
      const isGuard = prediction.zodiac.guard.includes(zodiac);
      const tag = isMain ? "ğŸ”¥" : (isGuard ? "ğŸ›¡ï¸" : "");
      zodiacDetails += `${rank}. ${zodiac}: ${score.toFixed(1)}åˆ† ${tag}\n`;
    });
    
    // æ³¢è‰²åˆ†æ•°è¯¦æƒ…
    let colorDetails = "<b>ğŸ¨ æ³¢è‰²è¯„åˆ†è¯¦æƒ…:</b>\n";
    const sortedColorScores = Object.entries(prediction.color.scores || {})
      .sort((a, b) => b[1] - a[1]);
    
    sortedColorScores.forEach(([color, score], index) => {
      const isMain = prediction.color.main === color;
      const isGuard = prediction.color.guard === color;
      const tag = isMain ? "ğŸ”¥" : (isGuard ? "ğŸ›¡ï¸" : "");
      colorDetails += `${CONFIG.EMOJI[color]} ${color}: ${score.toFixed(1)}åˆ† ${tag}\n`;
    });
    
    // å°¾æ•°è¯¦æƒ…
    let tailDetails = "<b>ğŸ”¢ å°¾æ•°è¯„åˆ†è¯¦æƒ… (Top 5):</b>\n";
    const sortedTailScores = Object.entries(prediction.tailScores || {})
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
    
    sortedTailScores.forEach(([tail, score], index) => {
      const isSelected = prediction.tail.includes(parseInt(tail));
      const tag = isSelected ? "âœ…" : "";
      tailDetails += `${tail}å°¾: ${score.toFixed(1)}åˆ† ${tag}\n`;
    });
    
    const details = `
<b>ğŸ“‹ é¢„æµ‹ç®—æ³•è¯¦æƒ…åˆ†æ</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${zodiacDetails}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${colorDetails}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${tailDetails}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ğŸ“ˆ ç®—æ³•æƒé‡å‚æ•°:</b>
${Object.entries(prediction.usedWeights || {}).map(([key, value]) => 
  `${key}: ${value.toFixed(2)}`
).join(" | ")}

<b>ğŸ§® æ•°æ®ç»Ÿè®¡:</b>
å†å²è®°å½•: ${prediction.totalHistoryRecords} æœŸ
ç”Ÿæˆæ—¶é—´: ${new Date(prediction.generatedAt).toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})}
ç®—æ³•ç‰ˆæœ¬: ${prediction.algorithmVersion}
    `.trim();
    
    return {
      text: details,
      keyboard: {
        inline_keyboard: [[
          { text: "ğŸ”™ è¿”å›é¢„æµ‹", callback_data: "back_to_preview" }
        ]]
      }
    };
  }

  /**
   * æ¸²æŸ“å¤ç›˜æŠ¥å‘Š
   */
  static renderBacktestReport(inputExpect, targetExpect, prediction, actualResult, evaluation, learnMsg = "") {
    const actualSpecial = parseInt(actualResult.open_code.split(",")[6]);
    const actAttr = Formatter.getAttributes(actualSpecial);
    
    const isZodiacWin = prediction.zodiac.main.includes(actAttr.zodiac);
    const isZodiacGuardWin = prediction.zodiac.guard.includes(actAttr.zodiac);
    const isColorWin = prediction.color.main === actAttr.color || prediction.color.guard === actAttr.color;
    const isTailWin = prediction.tail.includes(actualSpecial % 10);
    const isHeadWin = parseInt(prediction.head.main) === Math.floor(actualSpecial / 10);
    const isShapeWin = prediction.shape === ((actualSpecial >= 25 ? "å¤§" : "å°") + (actualSpecial % 2 !== 0 ? "å•" : "åŒ"));
    
    const zodiacResult = isZodiacWin ? CONFIG.EMOJI.win + " ä¸»ä¸­!" : 
                        (isZodiacGuardWin ? "ğŸ†— é˜²ä¸­" : CONFIG.EMOJI.loss + " æœªä¸­");
    const colorResult = isColorWin ? CONFIG.EMOJI.win + " å‘½ä¸­" : CONFIG.EMOJI.loss + " æœªä¸­";
    const tailResult = isTailWin ? CONFIG.EMOJI.win + " å‘½ä¸­" : CONFIG.EMOJI.loss + " æœªä¸­";
    
    return `
<b>ğŸ“‰ æ—¶å…‰æœºå¤ç›˜æŠ¥å‘Š</b>
åŸºå‡†æœŸå·: ${inputExpect}
é¢„æµ‹ç›®æ ‡: <b>${targetExpect}</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>1ï¸âƒ£ ç”Ÿè‚–éªŒè¯</b>
é¢„æµ‹: ğŸ”¥[${prediction.zodiac.main.join(" ")}] ğŸ›¡[${prediction.zodiac.guard.join(" ")}]
å¼€å¥–: <b>${actAttr.zodiac}</b> ${zodiacResult}

<b>2ï¸âƒ£ æ³¢è‰²éªŒè¯</b>
é¢„æµ‹: ä¸»${CONFIG.EMOJI[prediction.color.main]} é˜²${CONFIG.EMOJI[prediction.color.guard]}
å¼€å¥–: ${CONFIG.EMOJI[actAttr.color]} ${colorResult}

<b>3ï¸âƒ£ å°¾æ•°éªŒè¯</b>
é¢„æµ‹: [${prediction.tail.join(", ")}]
å¼€å¥–: ${actualSpecial % 10}å°¾ ${tailResult}

<b>4ï¸âƒ£ å…¶ä»–éªŒè¯</b>
å¤´æ•°: ${isHeadWin ? CONFIG.EMOJI.win : CONFIG.EMOJI.loss} | å½¢æ€: ${isShapeWin ? CONFIG.EMOJI.win : CONFIG.EMOJI.loss}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ğŸ“ çœŸå®å¼€å¥–</b>: ${Formatter.formatOpenCode(actualResult.open_code)}
ç‰¹ç : ${actualSpecial} (${actAttr.zodiac}/${CONFIG.EMOJI[actAttr.color]})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<b>ğŸ“ˆ ç»¼åˆè¯„åˆ†</b>
å¾—åˆ†: ${evaluation.totalScore}/100
ç­‰çº§: ${evaluation.grade}
ç½®ä¿¡åº¦: ${prediction.confidence}%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${learnMsg}
<b>â° å¤ç›˜æ—¶é—´</b>: ${Formatter.formatBeijingTime()}
    `.trim();
  }

  /**
   * æ¸²æŸ“æˆ˜ç»©ç»Ÿè®¡
   */
  static renderScoreboard(archives, stats) {
    if (!archives || archives.length === 0) {
      return `<b>${CONFIG.EMOJI.score} é¢„æµ‹æˆ˜ç»©</b>\n\næš‚æ— å·²å¼€å¥–çš„æˆ˜ç»©è®°å½•ã€‚`;
    }
    
    let message = `<b>${CONFIG.EMOJI.score} è¿‘æœŸé¢„æµ‹æˆ˜ç»©</b>\n\n`;
    
    // æ˜¾ç¤ºæœ€è¿‘10æœŸ
    const recentArchives = archives.slice(0, 10);
    
    recentArchives.forEach(archive => {
      const icon = archive.result_status === "WIN" ? CONFIG.EMOJI.win : CONFIG.EMOJI.loss;
      const detail = archive.hit_detail || "æ— è¯¦æƒ…";
      message += `ç¬¬ ${archive.expect} æœŸ: ${icon} ${detail}\n`;
    });
    
    // ç»Ÿè®¡ä¿¡æ¯
    if (stats) {
      message += `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      message += `<b>ğŸ“Š ç»Ÿè®¡æ¦‚è§ˆ</b>\n`;
      message += `æ€»åœºæ¬¡: ${stats.totalMatches}\n`;
      message += `èƒœåˆ©åœºæ¬¡: ${stats.wins} (${stats.winRate}%)\n`;
      message += `å¹³å‡å¾—åˆ†: ${stats.avgScore.toFixed(1)}\n`;
      message += `æœ€é«˜å¾—åˆ†: ${stats.maxScore}\n`;
      message += `æœ€è¿‘è¿èƒœ: ${stats.currentStreak}\n`;
      message += `æœ€é•¿è¿èƒœ: ${stats.maxStreak}\n`;
    }
    
    message += `\n<b>ğŸ“… ç»Ÿè®¡æ—¶é—´</b>: ${Formatter.formatBeijingTime()}`;
    
    return message;
  }

  /**
   * æ¸²æŸ“ç³»ç»ŸçŠ¶æ€
   */
  static renderSystemStatus(stats, settings, task) {
    let message = `<b>${CONFIG.EMOJI.bell} ç³»ç»ŸçŠ¶æ€æŠ¥å‘Š</b>\n\n`;
    
    // æ•°æ®ç»Ÿè®¡
    message += `<b>ğŸ“Š æ•°æ®ç»Ÿè®¡</b>\n`;
    message += `å†å²è®°å½•: ${stats.historyCount} æœŸ\n`;
    message += `é¢„æµ‹å½’æ¡£: ${stats.archiveCount} æ¬¡\n`;
    message += `æ•°æ®èŒƒå›´: ${stats.earliestExpect || "æ— "} - ${stats.latestExpect || "æ— "}\n`;
    
    // ä»»åŠ¡çŠ¶æ€
    message += `\n<b>ğŸ”„ å½“å‰ä»»åŠ¡</b>\n`;
    if (task) {
      const statusText = task.status === "DONE" ? "å·²å®Œæˆ" : 
                        task.status === "CALCULATING" ? "è®¡ç®—ä¸­" : "ç­‰å¾…ä¸­";
      const sentText = task.isSent ? "å·²æ¨é€" : "æœªæ¨é€";
      
      message += `æœŸå·: ${task.expect}\n`;
      message += `çŠ¶æ€: ${statusText} | ${sentText}\n`;
      
      if (task.status === "CALCULATING") {
        const progress = task.targetSims > 0 ? 
          ((task.currentSims / task.targetSims) * 100).toFixed(1) : 0;
        const progressBar = Formatter.generateProgressBar(task.currentSims, task.targetSims);
        message += `è¿›åº¦: ${progressBar} ${progress}%\n`;
      }
    } else {
      message += `æ— æ´»åŠ¨ä»»åŠ¡\n`;
    }
    
    // ç³»ç»Ÿè®¾ç½®
    message += `\n<b>âš™ï¸ ç³»ç»Ÿè®¾ç½®</b>\n`;
    message += `è‡ªåŠ¨æ¨é€: ${settings.AUTO_PUSH === "ON" ? "å¼€å¯" : "å…³é—­"}\n`;
    
    if (settings.AUTO_PUSH === "ON") {
      message += `å®šæ—¶æ¨é€: ${Formatter.formatTime(settings.SCHEDULE_TIME)}\n`;
      if (settings.SCHEDULE_TIME !== "OFF") {
        const lastPush = settings.LAST_SCHEDULE_PUSH || "ä»æœªæ¨é€";
        message += `ä¸Šæ¬¡å®šæ—¶: ${lastPush}\n`;
      }
    }
    
    message += `è¿ç®—æ—¶é•¿: ${parseInt(settings.DURATION || CONFIG.SYSTEM.DEFAULT_DURATION) / 3600000}å°æ—¶\n`;
    
    // ç®—æ³•ä¿¡æ¯
    message += `\n<b>ğŸ§  ç®—æ³•ä¿¡æ¯</b>\n`;
    message += `ç³»ç»Ÿç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n`;
    
    try {
      const weights = settings.ALGO_WEIGHTS ? JSON.parse(settings.ALGO_WEIGHTS) : CONFIG.DEFAULT_ALGO_WEIGHTS;
      message += `æƒé‡ç‰ˆæœ¬: v${weights._version || "1.0"}\n`;
    } catch (e) {
      message += `æƒé‡ç‰ˆæœ¬: é»˜è®¤\n`;
    }
    
    // åŒæ­¥ä¿¡æ¯
    message += `\n<b>ğŸ”„ åŒæ­¥ä¿¡æ¯</b>\n`;
    message += `ä¸Šæ¬¡åŒæ­¥: ${settings.LAST_SYNC || "ä»æœªåŒæ­¥"}\n`;
    message += `æ€»åŒæ­¥æ¬¡æ•°: ${settings.TOTAL_SYNCS || "0"}\n`;
    message += `æ€»æ¨é€æ¬¡æ•°: ${settings.TOTAL_PUSHES || "0"}\n`;
    
    message += `\n<b>â° æŠ¥å‘Šæ—¶é—´</b>: ${Formatter.formatBeijingTime()}`;
    
    return message;
  }

  /**
   * æ¸²æŸ“å¸®åŠ©ä¿¡æ¯
   */
  static renderHelp() {
    return `
<b>${CONFIG.EMOJI.help} ${CONFIG.SYSTEM.NAME} ä½¿ç”¨å¸®åŠ©</b>

<u>æ ¸å¿ƒåŠŸèƒ½</u>
<b>1. æ™ºèƒ½é¢„æµ‹</b>
ç‚¹å‡»"${BTNS.PREVIEW}"æŸ¥çœ‹æœ€æ–°é¢„æµ‹
ç‚¹å‡»"${BTNS.REC}"æŸ¥çœ‹å†å²å¼€å¥–è®°å½•

<b>2. æ—¶å…‰æœºå¤ç›˜</b>
å‘é€ <code>å¤ç›˜ æœŸå·</code>
ä¾‹å¦‚: <code>å¤ç›˜ 2024130</code>
ç³»ç»Ÿä¼šå›åˆ°è¯¥æœŸï¼Œæ¨¡æ‹Ÿé¢„æµ‹å¹¶å­¦ä¹ 

<b>3. æˆ˜ç»©ç»Ÿè®¡</b>
ç‚¹å‡»"${BTNS.SCORE}"æŸ¥çœ‹å†å²é¢„æµ‹å‡†ç¡®ç‡

<u>ç®¡ç†å‘˜åŠŸèƒ½</u>
<b>1. æ•°æ®ç®¡ç†</b>
"${BTNS.SYNC}": ä»URLåŒæ­¥å†å²æ•°æ®
"${BTNS.RESET}": é‡ç½®å½“å‰é¢„æµ‹ä»»åŠ¡

<b>2. æ¨é€è®¾ç½®</b>
"${BTNS.AUTO}": åˆ‡æ¢è‡ªåŠ¨æ¨é€
"${BTNS.SCHEDULE}": è®¾ç½®å®šæ—¶æ¨é€æ—¶é—´
"${BTNS.PUSH}": ç«‹å³æ¨é€é¢„æµ‹

<b>3. ç³»ç»Ÿè®¾ç½®</b>
"${BTNS.TIME}": è®¾ç½®è¿ç®—æ—¶é•¿
"${BTNS.LEARN}": å¼ºåˆ¶å­¦ä¹ æœ€æ–°æ•°æ®
"${BTNS.STATUS}": æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€

<u>AIåŠ©æ‰‹</u>
ç‚¹å‡»"AIåŠ©æ‰‹"æŒ‰é’®è¿›å…¥èŠå¤©æ¨¡å¼
å¯å’¨è¯¢æ•°æ®åˆ†æã€ç®—æ³•åŸç†ç­‰é—®é¢˜

<u>ä½¿ç”¨ç¤ºä¾‹</u>
1. æŸ¥çœ‹é¢„æµ‹: ç‚¹å‡»"${BTNS.PREVIEW}"
2. å¤ç›˜å­¦ä¹ : å‘é€"å¤ç›˜ 2024120"
3. åŒæ­¥æ•°æ®: ç‚¹å‡»"${BTNS.SYNC}"
4. è®¾ç½®å®šæ—¶: ç‚¹å‡»"${BTNS.SCHEDULE}" â†’ "å®šæ—¶ 20:00"

<b>ğŸ“ æŠ€æœ¯æ”¯æŒ</b>
ç³»ç»Ÿç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}
ç®—æ³•: é©¬å°”å¯å¤«é“¾ + é—æ¼å€¼å›å½’ + åŠ¨æ€æƒé‡
æ•°æ®æº: é…ç½®çš„URLæ¥å£
    `.trim();
  }

  /**
   * æ¸²æŸ“å®šæ—¶è®¾ç½®ç•Œé¢
   */
  static renderScheduleSettings(currentTime, lastPush) {
    return `
<b>${CONFIG.EMOJI.calendar} å®šæ—¶æ¨é€è®¾ç½®</b>

<u>å½“å‰è®¾ç½®</u>
å®šæ—¶æ—¶é—´: ${Formatter.formatTime(currentTime)}
ä¸Šæ¬¡æ¨é€: ${lastPush || "ä»æœªæ¨é€"}

<u>è®¾ç½®è¯´æ˜</u>
1. ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¿«é€Ÿè®¾ç½®å¸¸ç”¨æ—¶é—´
2. æˆ–å‘é€ <code>å®šæ—¶ HH:MM</code> è‡ªå®šä¹‰æ—¶é—´
   ä¾‹å¦‚: <code>å®šæ—¶ 09:30</code>
3. å‘é€ <code>å®šæ—¶å…³é—­</code> å…³é—­å®šæ—¶æ¨é€
4. ç‚¹å‡»"æŸ¥çœ‹å®šæ—¶"æŸ¥çœ‹å½“å‰è®¾ç½®

<u>æ³¨æ„äº‹é¡¹</u>
â€¢ éœ€è¦å…ˆå¼€å¯"è‡ªåŠ¨æ¨é€"
â€¢ ä½¿ç”¨åŒ—äº¬æ—¶é—´ (UTC+8)
â€¢ æ¯å¤©åªä¼šåœ¨è®¾å®šæ—¶é—´æ¨é€ä¸€æ¬¡
â€¢ å¦‚æœåˆ°æ—¶é¢„æµ‹æœªå®Œæˆï¼Œä¼šç­‰å¾…ä¸‹æ¬¡
    `.trim();
  }
}

// ==============================================================================
// 7. å¤–éƒ¨æ¥å£å°è£… (External Integrations) - å®Œæ•´ç‰ˆ
// ==============================================================================

class ExternalService {
  /**
   * å‘é€ Telegram æ¶ˆæ¯
   */
  static async sendMessage(env, chatId, text, keyboard = null, parseMode = "HTML") {
    const body = {
      chat_id: chatId,
      text: text,
      parse_mode: parseMode,
      disable_web_page_preview: true,
      disable_notification: false
    };
    
    if (keyboard) body.reply_markup = keyboard;

    try {
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `sendMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "sendMessage network error", error);
      return null;
    }
  }

  /**
   * ç¼–è¾‘ Telegram æ¶ˆæ¯
   */
  static async editMessage(env, chatId, messageId, text, keyboard = null) {
    const body = {
      chat_id: chatId,
      message_id: messageId,
      text: text,
      parse_mode: "HTML",
      disable_web_page_preview: true
    };
    
    if (keyboard) body.reply_markup = keyboard;

    try {
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/editMessageText`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        Logger.error("Telegram", `editMessage failed: ${result.description}`, result);
        return null;
      }
      
      return result;
    } catch (error) {
      Logger.error("Telegram", "editMessage network error", error);
      return null;
    }
  }

  /**
   * å›ç­”å›è°ƒæŸ¥è¯¢
   */
  static async answerCallbackQuery(env, callbackQueryId, text = "å¤„ç†ä¸­...", showAlert = false) {
    try {
      const response = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/answerCallbackQuery`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          callback_query_id: callbackQueryId,
          text: text,
          show_alert: showAlert
        })
      });
      
      return await response.json();
    } catch (error) {
      Logger.error("Telegram", "answerCallbackQuery failed", error);
      return null;
    }
  }

  /**
   * ä» URL åŒæ­¥å†å²æ•°æ®
   */
  static async syncHistoryFromUrl(env) {
    if (!env.LOTTERY_DATA_URL) {
      return { success: false, error: 'æœªé…ç½® LOTTERY_DATA_URL ç¯å¢ƒå˜é‡' };
    }

    try {
      Logger.info("Sync", `å¼€å§‹ä» ${env.LOTTERY_DATA_URL} åŒæ­¥æ•°æ®`);
      
      const response = await fetch(env.LOTTERY_DATA_URL, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) MarkSixBot/5.0',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        },
        timeout: 30000
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
      }

      const data = await response.json();
      let records = [];

      // å¤šç§æ•°æ®æ ¼å¼å…¼å®¹
      if (data.result === true && Array.isArray(data.data)) {
        // æ ¼å¼1: {result: true, data: [...]}
        Logger.info("Sync", `æ£€æµ‹åˆ°æ ‡å‡†æ ¼å¼ï¼Œå…± ${data.data.length} æ¡è®°å½•`);
        records = this.parseRecordsFormat1(data.data);
      } else if (Array.isArray(data)) {
        // æ ¼å¼2: [...]
        Logger.info("Sync", `æ£€æµ‹åˆ°æ•°ç»„æ ¼å¼ï¼Œå…± ${data.length} æ¡è®°å½•`);
        records = this.parseRecordsFormat2(data);
      } else if (data.data && Array.isArray(data.data)) {
        // æ ¼å¼3: {data: [...]}
        Logger.info("Sync", `æ£€æµ‹åˆ°dataæ•°ç»„æ ¼å¼ï¼Œå…± ${data.data.length} æ¡è®°å½•`);
        records = this.parseRecordsFormat2(data.data);
      } else {
        throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
      }

      if (records.length === 0) {
        return { success: false, error: 'æœªè§£æåˆ°æœ‰æ•ˆå¼€å¥–è®°å½•' };
      }

      // æ’åºï¼ˆä»æ–°åˆ°æ—§ï¼‰
      records.sort((a, b) => parseInt(b.expect) - parseInt(a.expect));

      // è¿‡æ»¤æ–°æ•°æ®
      const latestInDB = await DB.getLatestExpect(env);
      let newRecords = [];

      if (latestInDB) {
        newRecords = records.filter(r => parseInt(r.expect) > parseInt(latestInDB));
        Logger.info("Sync", `æ•°æ®åº“æœ€æ–°æœŸå·: ${latestInDB}, å‘ç° ${newRecords.length} æ¡æ–°è®°å½•`);
      } else {
        newRecords = records;
        Logger.info("Sync", `æ•°æ®åº“ä¸ºç©ºï¼Œæ‰€æœ‰ ${records.length} æ¡è®°å½•éƒ½æ˜¯æ–°çš„`);
      }

      if (newRecords.length === 0) {
        return { 
          success: true, 
          total: records.length, 
          added: 0, 
          newCount: 0,
          message: 'æ²¡æœ‰å‘ç°æ–°è®°å½•ï¼Œæ•°æ®å·²æ˜¯æœ€æ–°' 
        };
      }

      // æ’å…¥æ—¶æŒ‰æ­£åºï¼ˆä»æ—§åˆ°æ–°ï¼‰
      newRecords.sort((a, b) => parseInt(a.expect) - parseInt(b.expect));
      const saveResult = await DB.batchAddHistory(env, newRecords);

      if (saveResult.success && saveResult.added > 0) {
        // æ›´æ–°åŒæ­¥ç»Ÿè®¡
        const totalSyncs = parseInt(await DB.getSetting(env, "TOTAL_SYNCS", "0")) + 1;
        await DB.saveSetting(env, "TOTAL_SYNCS", totalSyncs.toString());
        await DB.saveSetting(env, "LAST_SYNC", Formatter.formatBeijingTime());
      }

      return {
        success: saveResult.success,
        total: records.length,
        added: saveResult.added || 0,
        skipped: saveResult.skipped || 0,
        newCount: newRecords.length,
        latestInDB: latestInDB,
        error: saveResult.error
      };

    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å†å²æ•°æ®å¤±è´¥", error);
      return { 
        success: false, 
        error: error.message || 'æœªçŸ¥é”™è¯¯',
        stack: error.stack
      };
    }
  }

  /**
   * è§£ææ•°æ®æ ¼å¼1
   */
  static parseRecordsFormat1(dataArray) {
    const records = [];
    
    for (const item of dataArray) {
      try {
        if (item.expect && item.openCode) {
          const expect = item.expect.toString().trim();
          const codeStr = item.openCode.toString().trim();
          
          const numbers = codeStr.split(/[,\s]+/)
            .map(n => parseInt(n))
            .filter(n => !isNaN(n) && n >= 1 && n <= 49);
          
          if (numbers.length === 7) {
            records.push({
              expect: expect,
              open_code: numbers.map(n => n.toString().padStart(2, '0')).join(","),
              raw: item
            });
          }
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }

  /**
   * è§£ææ•°æ®æ ¼å¼2
   */
  static parseRecordsFormat2(dataArray) {
    const records = [];
    
    for (const item of dataArray) {
      try {
        const expect = (item.expect || item.issue || item.code).toString().trim();
        const codeStr = (item.open_code || item.openCode || item.code_number || item.number).toString().trim();
        
        if (!expect || !codeStr) continue;
        
        const numbers = codeStr.split(/[,\s]+/)
          .map(n => parseInt(n))
          .filter(n => !isNaN(n) && n >= 1 && n <= 49);
        
        if (numbers.length === 7) {
          records.push({
            expect: expect,
            open_code: numbers.map(n => n.toString().padStart(2, '0')).join(","),
            raw: item
          });
        }
      } catch (e) {
        Logger.warn("Sync", `è§£æè®°å½•å¤±è´¥: ${JSON.stringify(item).substring(0, 100)}`);
      }
    }
    
    return records;
  }

  /**
   * è°ƒç”¨AIæœåŠ¡
   */
  static async callAI(env, prompt, context = null) {
    if (!env.AI) {
      throw new Error('AIæœåŠ¡æœªå¯ç”¨');
    }
    
    try {
      const messages = [];
      
      // ç³»ç»Ÿæç¤º
      messages.push({
        role: "system",
        content: `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å…­åˆå½©æ•°æ®åˆ†æåŠ©æ‰‹ã€‚è¯·ä»¥ä¸“ä¸šã€å®¢è§‚ã€ç§‘å­¦çš„æ€åº¦å›ç­”ç”¨æˆ·é—®é¢˜ã€‚ä¸è¦æä¾›èµŒåšå»ºè®®ï¼Œè€Œæ˜¯ä»ç»Ÿè®¡å­¦ã€æ¦‚ç‡å­¦å’Œæ•°æ®åˆ†æçš„è§’åº¦è¿›è¡Œè§£é‡Šã€‚
        
        ä½ å¯ä»¥è®¿é—®ä»¥ä¸‹ç³»ç»Ÿä¿¡æ¯ï¼š
        ç³»ç»Ÿåç§°: ${CONFIG.SYSTEM.NAME}
        ç³»ç»Ÿç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}
        åˆ†æç®—æ³•: é©¬å°”å¯å¤«é“¾è½¬ç§»çŸ©é˜µã€é—æ¼å€¼å›å½’åˆ†æã€åŠ¨æ€æƒé‡è°ƒæ•´
        æ•°æ®æ¥æº: å†å²å¼€å¥–è®°å½•åˆ†æ
        
        è¯·ä¿æŒå›ç­”ä¸“ä¸šä¸”æ˜“æ‡‚ã€‚`
      });
      
      // æ·»åŠ ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœæœ‰ï¼‰
      if (context) {
        messages.push({
          role: "system",
          content: `å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡: ${JSON.stringify(context, null, 2)}`
        });
      }
      
      // ç”¨æˆ·é—®é¢˜
      messages.push({
        role: "user",
        content: prompt
      });
      
      const response = await env.AI.run(CONFIG.SYSTEM.AI_MODEL, { 
        messages,
        max_tokens: 1000
      });
      
      return response.response;
    } catch (error) {
      Logger.error("AI", "AIè°ƒç”¨å¤±è´¥", error);
      throw error;
    }
  }
}

// ==============================================================================
// 8. ä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨ (Business Logic Controllers) - å®Œæ•´ç‰ˆ
// ==============================================================================

class Controller {
  /**
   * åˆå§‹åŒ–ä»»åŠ¡
   */
  static async initTask(env, history) {
    const duration = parseInt(await DB.getSetting(env, "DURATION", CONFIG.SYSTEM.DEFAULT_DURATION));
    
    let nextExpect = "2025001";
    if (history.length > 0) {
      const latestExpect = parseInt(history[0].expect);
      nextExpect = (latestExpect + 1).toString();
    }

    const newTask = {
      startTime: Date.now(),
      unlockTime: Date.now() + duration,
      expect: nextExpect,
      status: "CALCULATING",
      currentSims: 0,
      targetSims: CONFIG.SYSTEM.TARGET_SIMS,
      history: history.slice(0, 500), // åªå­˜å‚¨æœ€è¿‘500æœŸï¼Œé¿å…æ•°æ®è¿‡å¤§
      finalPrediction: null,
      isSent: 0,
      predictionVersion: Date.now(),
      algorithmVersion: "V5.0"
    };

    await DB.saveTask(env, newTask);
    Logger.info("Task", `åˆå§‹åŒ–ä»»åŠ¡: æœŸå· ${nextExpect}, è§£é”æ—¶é—´ ${new Date(newTask.unlockTime).toLocaleString('zh-CN')}`);
    return newTask;
  }

  /**
   * å¤„ç†å†å²è®°å½•æŸ¥çœ‹
   */
  static async handleHistory(env, chatId, page = 1, messageId = null) {
    const RECORDS_PER_PAGE = 10;
    const offset = (page - 1) * RECORDS_PER_PAGE;

    const history = await DB.getHistory(env, RECORDS_PER_PAGE, offset);
    if (!history || history.length === 0) {
      const txt = `ğŸ“Š <b>${CONFIG.SYSTEM.NAME}</b>\næš‚æ— å¼€å¥–å†å²è®°å½•ï¼Œè¯·å…ˆåˆ°ç®¡ç†èœå•åŒæ­¥æ•°æ®ã€‚`;
      if (messageId) await ExternalService.editMessage(env, chatId, messageId, txt);
      else await ExternalService.sendMessage(env, chatId, txt);
      return;
    }

    const totalRecords = await DB.getHistoryCount(env);
    const totalPages = Math.ceil(totalRecords / RECORDS_PER_PAGE);

    let message = `<b>${CONFIG.EMOJI.history} å†å²å¼€å¥–è®°å½•</b>\n`;
    message += `ç¬¬ ${page}/${totalPages} é¡µ | å…± ${totalRecords} æœŸ\n`;
    message += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;

    history.forEach(r => {
      const special = parseInt(r.open_code.split(",")[6]);
      const attr = Formatter.getAttributes(special);
      message += `ç¬¬ <b>${r.expect}</b> æœŸ: ${Formatter.formatOpenCode(r.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
    });

    // ç¿»é¡µé”®ç›˜
    const keyboard = { inline_keyboard: [] };
    const navRow = [];
    
    if (page > 1) {
      navRow.push({ text: "â—€ï¸ ä¸Šä¸€é¡µ", callback_data: `history_page_${page - 1}` });
    }
    
    navRow.push({ text: `ğŸ“„ ${page}/${totalPages}`, callback_data: "current_page" });
    
    if (page < totalPages) {
      navRow.push({ text: "ä¸‹ä¸€é¡µ â–¶ï¸", callback_data: `history_page_${page + 1}` });
    }
    
    keyboard.inline_keyboard.push(navRow);
    keyboard.inline_keyboard.push([{ text: "ğŸ”™ è¿”å›èœå•", callback_data: "back_to_menu" }]);

    if (messageId) {
      await ExternalService.editMessage(env, chatId, messageId, message, keyboard);
    } else {
      await ExternalService.sendMessage(env, chatId, message, keyboard);
    }
  }

  /**
   * å¤„ç†é¢„æµ‹é¢„è§ˆ
   */
  static async handlePreview(env, chatId, messageId = null) {
    try {
      Logger.info("Preview", `å¤„ç†é¢„è§ˆè¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      let task = await DB.getTask(env);

      // å¦‚æœæ²¡æœ‰ä»»åŠ¡ï¼Œå°è¯•åˆå§‹åŒ–ä¸€ä¸ª
      if (!task) {
        const history = await DB.getHistory(env);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
          Logger.info("Preview", `åˆå§‹åŒ–æ–°ä»»åŠ¡: ${task.expect}`);
        } else {
          const message = `ğŸ”® <b>${CONFIG.SYSTEM.NAME}</b>\nå½“å‰æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆé¢„æµ‹ã€‚è¯·å…ˆåŒæ­¥æ•°æ®ã€‚`;
          
          if (messageId) {
            await ExternalService.editMessage(env, chatId, messageId, message);
          } else {
            await ExternalService.sendMessage(env, chatId, message);
          }
          return;
        }
      }

      // è·å–æ•°æ®å’Œæƒé‡
      const allHistory = await DB.getHistory(env);
      const historicalAnalysis = MathEngine.analyzeBasicStats(allHistory);
      const weights = await DB.getWeights(env);
      
      // æ›´æ–°ä»»åŠ¡è¿›åº¦ï¼ˆæ¨¡æ‹Ÿï¼‰
      if (task.status === "CALCULATING") {
        const timePassed = Date.now() - task.startTime;
        const totalDuration = task.unlockTime - task.startTime;
        const progress = Math.min(1, timePassed / totalDuration);
        
        task.currentSims = Math.min(task.targetSims, Math.floor(progress * task.targetSims));
        
        if (Date.now() >= task.unlockTime) {
          task.status = "DONE";
          task.currentSims = task.targetSims;
        }
        
        await DB.saveTask(env, task);
      }

      // ç”Ÿæˆé¢„æµ‹
      let prediction;
      if (task.finalPrediction && task.status === "DONE") {
        // ä½¿ç”¨å·²å®Œæˆçš„é¢„æµ‹
        prediction = task.finalPrediction;
        Logger.debug("Preview", `ä½¿ç”¨å·²ä¿å­˜çš„é¢„æµ‹: ${task.expect}`);
      } else {
        // ç”Ÿæˆæ–°é¢„æµ‹
        const determinants = MathEngine.analyzeDeterminants(allHistory);
        prediction = PredictionEngine.generate(task, historicalAnalysis, weights, determinants);
        
        // å¦‚æœä»»åŠ¡å·²å®Œæˆï¼Œä¿å­˜é¢„æµ‹ç»“æœ
        if (task.status === "DONE") {
          task.finalPrediction = prediction;
          await DB.saveTask(env, task);
          await DB.archivePrediction(env, task.expect, prediction);
          Logger.info("Preview", `é¢„æµ‹å®Œæˆå¹¶ä¿å­˜: ${task.expect}`);
        }
      }

      // æ¸²æŸ“æ¶ˆæ¯
      const msgData = MessageRenderer.renderPreview(prediction, task, true, weights);
      
      if (messageId) {
        await ExternalService.editMessage(env, chatId, messageId, msgData.text, msgData.keyboard);
      } else {
        await ExternalService.sendMessage(env, chatId, msgData.text, msgData.keyboard);
      }
      
      Logger.info("Preview", `é¢„è§ˆå‘é€å®Œæˆ: ${task.expect}, ç½®ä¿¡åº¦: ${prediction.confidence}%`);
      
    } catch (error) {
      Logger.error("Preview", "å¤„ç†é¢„è§ˆå¤±è´¥", error);
      
      const errorMessage = `âŒ <b>ç”Ÿæˆé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>\n\nè¯·ç¨åé‡è¯•æˆ–è”ç³»ç®¡ç†å‘˜ã€‚`;
      
      if (messageId) {
        await ExternalService.editMessage(env, chatId, messageId, errorMessage);
      } else {
        await ExternalService.sendMessage(env, chatId, errorMessage);
      }
    }
  }

  /**
   * å¤„ç†å¤ç›˜å›æµ‹ä¸å­¦ä¹ 
   */
  static async handleBacktest(env, chatId, inputExpect) {
    try {
      Logger.info("Backtest", `å¼€å§‹å¤ç›˜: ${inputExpect}, chatId: ${chatId}`);
      
      const allHistory = await DB.getHistory(env);
      if (!allHistory || allHistory.length === 0) {
        await ExternalService.sendMessage(env, chatId, "âŒ æ•°æ®åº“ä¸ºç©ºï¼Œæ— æ³•æ‰§è¡Œå¤ç›˜ã€‚è¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚");
        return;
      }

      // 1. å®šä½æœŸå·
      const index = allHistory.findIndex(h => h.expect === inputExpect.toString());
      
      if (index === -1) {
        await ExternalService.sendMessage(env, chatId, `âŒ æœªæ‰¾åˆ°ç¬¬ ${inputExpect} æœŸçš„è®°å½•ã€‚è¯·æ£€æŸ¥æœŸå·æ˜¯å¦æ­£ç¡®ã€‚`);
        return;
      }

      if (index === 0) {
        await ExternalService.sendMessage(env, chatId, `âš ï¸ ç¬¬ ${inputExpect} æœŸæ˜¯æœ€æ–°ä¸€æœŸï¼Œæ²¡æœ‰æœªæ¥æ•°æ®å¯ä¾›éªŒè¯ã€‚è¯·é€‰æ‹©æ›´æ—©çš„æœŸæ•°ã€‚`);
        return;
      }

      // 2. åˆ‡å‰²æ•°æ®
      const pastHistory = allHistory.slice(index); // ä»è¯¥æœŸå¼€å§‹çš„å†å²
      const actualResultRecord = allHistory[index - 1]; // è¦é¢„æµ‹çš„é‚£ä¸€æœŸ
      const targetExpect = actualResultRecord.expect;

      // å‘é€å¼€å§‹æ¶ˆæ¯
      await ExternalService.sendMessage(env, chatId, 
        `â³ <b>å¯åŠ¨æ—¶å…‰æœº...</b>\n\n` +
        `å›é€€è‡³: ç¬¬ ${inputExpect} æœŸ\n` +
        `é¢„æµ‹ç›®æ ‡: ç¬¬ ${targetExpect} æœŸ\n` +
        `å†å²æ•°æ®: ${pastHistory.length} æœŸ\n\n` +
        `æ­£åœ¨åº”ç”¨å½“å‰ç®—æ³•è¿›è¡Œæ¨¡æ‹Ÿé¢„æµ‹...`
      );

      // 3. è·å–æƒé‡
      const weights = await DB.getWeights(env);

      // 4. æ‰§è¡Œé¢„æµ‹
      const prediction = await PredictionEngine.generateBacktestPrediction(env, targetExpect, pastHistory);
      
      // 5. éªŒè¯ç»“æœ
      const actSpecial = parseInt(actualResultRecord.open_code.split(",")[6]);
      const evaluation = PredictionEngine.evaluatePrediction(prediction, actSpecial);

      // 6. è‡ªä¸»å­¦ä¹ é€»è¾‘
      let learnMsg = "";
      const actAttr = Formatter.getAttributes(actSpecial);
      
      if (!evaluation.zodiacHit.main && !evaluation.zodiacHit.guard) {
        // ç”Ÿè‚–é¢„æµ‹å¤±è´¥ï¼Œåˆ†æåŸå› å¹¶è°ƒæ•´æƒé‡
        learnMsg = `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nğŸ§  <b>è‡ªä¸»å­¦ä¹ åˆ†æ</b>\n`;
        learnMsg += `é¢„æµ‹å¤±è´¥ã€‚çœŸå®ç”Ÿè‚–ä¸º <b>${actAttr.zodiac}</b>ã€‚\n`;
        learnMsg += `ç³»ç»Ÿæ­£åœ¨åˆ†æå¤±è´¥åŸå› å¹¶ä¼˜åŒ–ç®—æ³•...\n\n`;

        // æ·±åº¦åŸå› åˆ†æ
        const determinants = MathEngine.analyzeDeterminants(pastHistory);
        const lastZodiac = Formatter.getAttributes(parseInt(pastHistory[0].open_code.split(",")[6])).zodiac;

        // æ£€æŸ¥é©¬å°”å¯å¤«å…³è”æ€§
        const transitions = determinants.transitionMatrix[lastZodiac] || {};
        const transCount = transitions[actAttr.zodiac] || 0;
        const totalTransitions = Object.values(transitions).reduce((a, b) => a + b, 0);

        // æ£€æŸ¥é—æ¼å€¼
        const omission = determinants.omission[actAttr.zodiac] || 0;

        let adjusted = false;
        let adjustmentLog = [];

        // ç­–ç•¥ A: å‘ç°é©¬å°”å¯å¤«å¼ºå…³è”æ¼åˆ¤ -> æé«˜é©¬å°”å¯å¤«æƒé‡
        if (transCount > 0 && totalTransitions > 0) {
          const transProb = transCount / totalTransitions;
          if (transProb > 0.2) { // è½¬ç§»æ¦‚ç‡è¶…è¿‡20%
            weights.w_markov = parseFloat((weights.w_markov + 0.15).toFixed(2));
            adjustmentLog.push(`é©¬å°”å¯å¤«æƒé‡ +0.15 (è½¬ç§»æ¦‚ç‡: ${(transProb*100).toFixed(1)}%)`);
            adjusted = true;
          }
        }

        // ç­–ç•¥ B: å‘ç°é—æ¼å€¼å¼‚å¸¸ -> è°ƒæ•´é—æ¼æƒé‡
        if (omission > 15) {
          // æå†·åå¼¹æ¼åˆ¤
          weights.w_omission = parseFloat((weights.w_omission + 0.2).toFixed(2));
          adjustmentLog.push(`é—æ¼æƒé‡ +0.20 (é—æ¼: ${omission}æœŸ)`);
          adjusted = true;
        } else if (omission <= 3) {
          // çƒ­å·è¿å¼€æ¼åˆ¤
          weights.w_omission = parseFloat((weights.w_omission - 0.1).toFixed(2));
          weights.w_freq = parseFloat((weights.w_freq + 0.1).toFixed(2));
          adjustmentLog.push(`é—æ¼æƒé‡ -0.10ï¼Œé¢‘ç‡æƒé‡ +0.10 (é—æ¼: ${omission}æœŸ)`);
          adjusted = true;
        }

        // ç­–ç•¥ C: æ£€æŸ¥ç”Ÿè‚–å…³ç³»
        if (CONFIG.RELATIONS.LIU_HE[lastZodiac] === actAttr.zodiac) {
          // å…­åˆå…³ç³»æ¼åˆ¤
          weights.w_relation = parseFloat((weights.w_relation + 0.15).toFixed(2));
          adjustmentLog.push(`å…³ç³»æƒé‡ +0.15 (å…­åˆå…³ç³»)`);
          adjusted = true;
        } else if (CONFIG.RELATIONS.SAN_HE[lastZodiac]?.includes(actAttr.zodiac)) {
          // ä¸‰åˆå…³ç³»æ¼åˆ¤
          weights.w_relation = parseFloat((weights.w_relation + 0.1).toFixed(2));
          adjustmentLog.push(`å…³ç³»æƒé‡ +0.10 (ä¸‰åˆå…³ç³»)`);
          adjusted = true;
        }

        // ç­–ç•¥ D: é»˜è®¤å¾®è°ƒ
        if (!adjusted) {
          // åŸºç¡€é¢‘ç‡è°ƒæ•´
          weights.w_freq = parseFloat((weights.w_freq + 0.05).toFixed(2));
          adjustmentLog.push(`é¢‘ç‡æƒé‡ +0.05 (å¸¸è§„ä¼˜åŒ–)`);
        }

        // æŒä¹…åŒ–æ–°æƒé‡
        await DB.saveWeights(env, weights);
        
        // æ·»åŠ ç‰ˆæœ¬æ ‡è®°
        weights._version = (parseFloat(weights._version || "1.0") + 0.01).toFixed(2);
        await DB.saveWeights(env, weights);

        // æ„å»ºè°ƒæ•´æ—¥å¿—
        if (adjustmentLog.length > 0) {
          learnMsg += `<b>ç®—æ³•è°ƒæ•´è®°å½•:</b>\n`;
          adjustmentLog.forEach(log => {
            learnMsg += `â¤ ${log}\n`;
          });
        }
        
        learnMsg += `\nâœ… <b>ç®—æ³•æ ¸å¿ƒå‚æ•°å·²æ›´æ–°ï¼</b>\n`;
        learnMsg += `æ–°æƒé‡ç‰ˆæœ¬: v${weights._version}\n`;
        learnMsg += `å†æ¬¡å¤ç›˜æ­¤æœŸå°†åº”ç”¨æ–°é€»è¾‘ï¼Œç»“æœå¯èƒ½æ”¹å˜ã€‚`;

      } else {
        learnMsg = `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nğŸ§  <b>è‡ªä¸»å­¦ä¹ åˆ†æ</b>\n`;
        if (evaluation.zodiacHit.main) {
          learnMsg += `âœ… é¢„æµ‹å‡†ç¡®ï¼ä¸»æ¨ç”Ÿè‚–å‘½ä¸­ï¼Œå½“å‰ç®—æ³•è¡¨ç°ä¼˜ç§€ã€‚\n`;
        } else {
          learnMsg += `ğŸ†— é¢„æµ‹éƒ¨åˆ†å‡†ç¡®ï¼Œé˜²å®ˆç”Ÿè‚–å‘½ä¸­ï¼Œç®—æ³•è¡¨ç°è‰¯å¥½ã€‚\n`;
        }
        learnMsg += `å½“å‰ç®—æ³•æƒé‡é…ç½®åˆç†ï¼Œä¿æŒä¸å˜ã€‚`;
        
        // å°å¹…ä¼˜åŒ–ä¼˜èƒœå‚æ•°
        if (evaluation.totalScore >= 70) {
          // è¡¨ç°ä¼˜ç§€ï¼Œå¼ºåŒ–å½“å‰é…ç½®
          const boostAmount = 0.02;
          Object.keys(weights).forEach(key => {
            if (!key.startsWith('_') && typeof weights[key] === 'number') {
              weights[key] = parseFloat((weights[key] + boostAmount).toFixed(2));
            }
          });
          await DB.saveWeights(env, weights);
          learnMsg += `\n\nğŸ’ª <b>å°å¹…å¼ºåŒ–ä¼˜èƒœå‚æ•°</b> (å„æƒé‡+${boostAmount})`;
        }
      }

      // 7. å‘é€æŠ¥å‘Š
      const report = MessageRenderer.renderBacktestReport(
        inputExpect, targetExpect, prediction, actualResultRecord, evaluation, learnMsg
      );

      await ExternalService.sendMessage(env, chatId, report);
      
      Logger.info("Backtest", `å¤ç›˜å®Œæˆ: ${inputExpect} â†’ ${targetExpect}, å¾—åˆ†: ${evaluation.totalScore}, ç­‰çº§: ${evaluation.grade}`);

    } catch (error) {
      Logger.error("Backtest", "å¤ç›˜å¤„ç†å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>å¤ç›˜è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>\n\nè¯·æ£€æŸ¥æœŸå·æ˜¯å¦æ­£ç¡®æˆ–ç¨åé‡è¯•ã€‚`
      );
    }
  }

  /**
   * å¤„ç†å¼ºåˆ¶å­¦ä¹ 
   */
  static async handleForceLearn(env, chatId) {
    try {
      await ExternalService.sendMessage(env, chatId, 
        `${CONFIG.EMOJI.learn} <b>å¼€å§‹å¼ºåˆ¶å­¦ä¹ ...</b>\n\n` +
        `ç³»ç»Ÿå°†åˆ†ææœ€è¿‘50æœŸæ•°æ®ï¼Œä¼˜åŒ–ç®—æ³•æƒé‡ã€‚`
      );
      
      const recentHistory = await DB.getRecentHistory(env, 50);
      if (recentHistory.length < 20) {
        await ExternalService.sendMessage(env, chatId, 
          `âŒ å†å²æ•°æ®ä¸è¶³ï¼Œéœ€è¦è‡³å°‘20æœŸæ•°æ®æ‰èƒ½è¿›è¡Œæœ‰æ•ˆå­¦ä¹ ã€‚\nå½“å‰ä»…æœ‰ ${recentHistory.length} æœŸæ•°æ®ã€‚`
        );
        return;
      }
      
      const allHistory = await DB.getHistory(env);
      const weights = await DB.getWeights(env);
      
      // åˆ†ææœ€è¿‘50æœŸçš„è¡¨ç°
      let totalScore = 0;
      let successfulPredictions = 0;
      const weightAdjustments = {};
      Object.keys(weights).forEach(key => {
        if (!key.startsWith('_')) weightAdjustments[key] = 0;
      });
      
      // æ¨¡æ‹Ÿæœ€è¿‘20æœŸçš„é¢„æµ‹ï¼ˆè·³è¿‡å¤ªè¿‘çš„ï¼‰
      const testCount = Math.min(20, recentHistory.length - 1);
      
      for (let i = 0; i < testCount; i++) {
        const testHistory = allHistory.slice(i); // ä»ç¬¬iæœŸå¼€å§‹çš„å†å²
        const targetRecord = allHistory[i - 1]; // è¦é¢„æµ‹çš„é‚£ä¸€æœŸ
        
        if (!targetRecord) continue;
        
        const mockTask = {
          expect: targetRecord.expect,
          history: testHistory,
          startTime: Date.now(),
          unlockTime: Date.now(),
          status: "DONE"
        };
        
        const analysis = MathEngine.analyzeBasicStats(testHistory);
        const determinants = MathEngine.analyzeDeterminants(testHistory);
        const prediction = PredictionEngine.generate(mockTask, analysis, weights, determinants);
        
        const actualSpecial = parseInt(targetRecord.open_code.split(",")[6]);
        const evaluation = PredictionEngine.evaluatePrediction(prediction, actualSpecial);
        
        totalScore += evaluation.totalScore;
        if (evaluation.zodiacHit.main || evaluation.zodiacHit.guard) {
          successfulPredictions++;
        }
        
        // æ ¹æ®è¡¨ç°è°ƒæ•´æƒé‡å€¾å‘
        if (evaluation.totalScore >= 60) {
          // è¡¨ç°å¥½ï¼Œå¢å¼ºå½“å‰æƒé‡
          Object.keys(weightAdjustments).forEach(key => {
            weightAdjustments[key] += 0.01;
          });
        } else {
          // è¡¨ç°å·®ï¼Œéœ€è¦è°ƒæ•´
          const actualAttr = Formatter.getAttributes(actualSpecial);
          const lastRecord = testHistory[0];
          const lastSpecial = parseInt(lastRecord.open_code.split(",")[6]);
          const lastAttr = Formatter.getAttributes(lastSpecial);
          
          // åˆ†æå¤±è´¥åŸå› 
          const determinants = MathEngine.analyzeDeterminants(testHistory);
          const transitions = determinants.transitionMatrix[lastAttr.zodiac] || {};
          const transCount = transitions[actualAttr.zodiac] || 0;
          const omission = determinants.omission[actualAttr.zodiac] || 0;
          
          if (transCount > 0) {
            // é©¬å°”å¯å¤«å…³è”æ¼åˆ¤
            weightAdjustments.w_markov += 0.02;
          }
          
          if (omission > 10) {
            // é—æ¼åå¼¹æ¼åˆ¤
            weightAdjustments.w_omission += 0.02;
          }
          
          if (CONFIG.RELATIONS.LIU_HE[lastAttr.zodiac] === actualAttr.zodiac || 
              CONFIG.RELATIONS.SAN_HE[lastAttr.zodiac]?.includes(actualAttr.zodiac)) {
            // å…³ç³»æ¼åˆ¤
            weightAdjustments.w_relation += 0.02;
          }
        }
      }
      
      // åº”ç”¨è°ƒæ•´
      const avgScore = totalScore / testCount;
      const successRate = (successfulPredictions / testCount) * 100;
      
      Object.keys(weightAdjustments).forEach(key => {
        weights[key] = parseFloat((weights[key] + weightAdjustments[key]).toFixed(2));
        // é™åˆ¶èŒƒå›´
        weights[key] = Math.max(0.1, Math.min(5.0, weights[key]));
      });
      
      // å¢åŠ ç‰ˆæœ¬å·
      weights._version = (parseFloat(weights._version || "1.0") + 0.1).toFixed(2);
      
      await DB.saveWeights(env, weights);
      
      const resultMessage = 
        `${CONFIG.EMOJI.learn} <b>å¼ºåˆ¶å­¦ä¹ å®Œæˆ</b>\n\n` +
        `<b>æµ‹è¯•ç»Ÿè®¡:</b>\n` +
        `æµ‹è¯•æœŸæ•°: ${testCount} æœŸ\n` +
        `å¹³å‡å¾—åˆ†: ${avgScore.toFixed(1)}/100\n` +
        `ç”Ÿè‚–å‘½ä¸­ç‡: ${successRate.toFixed(1)}%\n\n` +
        `<b>æƒé‡è°ƒæ•´:</b>\n` +
        Object.entries(weightAdjustments)
          .filter(([_, value]) => Math.abs(value) > 0.001)
          .map(([key, value]) => `${key}: ${value > 0 ? '+' : ''}${value.toFixed(2)}`)
          .join('\n') +
        `\n\n<b>æ–°æƒé‡ç‰ˆæœ¬:</b> v${weights._version}\n` +
        `<b>å­¦ä¹ æ—¶é—´:</b> ${Formatter.formatBeijingTime()}`;
      
      await ExternalService.sendMessage(env, chatId, resultMessage);
      
      Logger.info("Learn", `å¼ºåˆ¶å­¦ä¹ å®Œæˆï¼Œå¹³å‡å¾—åˆ†: ${avgScore.toFixed(1)}, å‘½ä¸­ç‡: ${successRate.toFixed(1)}%`);
      
    } catch (error) {
      Logger.error("Learn", "å¼ºåˆ¶å­¦ä¹ å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>å¼ºåˆ¶å­¦ä¹ è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†åŒæ­¥æ•°æ®
   */
  static async handleSync(env, chatId) {
    try {
      Logger.info("Sync", `æ‰‹åŠ¨åŒæ­¥è¯·æ±‚ï¼ŒchatId: ${chatId}`);
      
      const statusMsg = await ExternalService.sendMessage(env, chatId, 
        `${CONFIG.EMOJI.sync} <b>æ­£åœ¨åŒæ­¥å†å²æ•°æ®...</b>\n\n` +
        `è¿æ¥æ•°æ®æº: ${env.LOTTERY_DATA_URL ? 'å·²é…ç½®' : 'æœªé…ç½®'}\n` +
        `å¼€å§‹æ—¶é—´: ${Formatter.formatBeijingTime()}`
      );
      
      const result = await ExternalService.syncHistoryFromUrl(env);
      
      if (result.success) {
        const history = await DB.getHistory(env);
        
        // é‡æ–°åˆå§‹åŒ–ä»»åŠ¡ï¼ˆå¦‚æœä¹‹å‰æ²¡æœ‰ï¼‰
        let task = await DB.getTask(env);
        if (!task && history.length > 0) {
          task = await Controller.initTask(env, history);
        } else if (task && history.length > 0) {
          // æ›´æ–°ä»»åŠ¡ä¸­çš„å†å²æ•°æ®
          task.history = history.slice(0, 500);
          await DB.saveTask(env, task);
        }
        
        let message = `âœ… <b>æ•°æ®åŒæ­¥å®Œæˆ</b>\n\n`;
        message += `æ•°æ®æºæ€»æ•°: ${result.total} æ¡\n`;
        message += `æˆåŠŸæ–°å¢: ${result.added} æ¡\n`;
        message += `è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡\n`;
        message += `æ•°æ®åº“æ€»æ•°: ${history.length} æ¡\n`;
        
        if (result.newCount > 0) {
          message += `\nğŸ“ <b>æœ€æ–°å¼€å¥–è®°å½•ï¼š</b>\n`;
          const newRecords = await DB.getHistory(env, 3);
          newRecords.forEach(record => {
            const special = parseInt(record.open_code.split(",")[6]);
            const attr = Formatter.getAttributes(special);
            message += `ç¬¬ ${record.expect} æœŸ: ${Formatter.formatOpenCode(record.open_code)} | ${attr.zodiac}${CONFIG.EMOJI[attr.color]}\n`;
          });
        }
        
        message += `\nğŸ”„ <b>ä»»åŠ¡çŠ¶æ€:</b> ${task ? `å·²æ›´æ–° (${task.expect})` : 'æ— ä»»åŠ¡'}`;
        message += `\nâ° <b>å®Œæˆæ—¶é—´:</b> ${Formatter.formatBeijingTime()}`;
        
        await ExternalService.sendMessage(env, chatId, message, KEYBOARDS.ADMIN_MENU);
        
      } else {
        await ExternalService.sendMessage(env, chatId, 
          `âŒ <b>æ•°æ®åŒæ­¥å¤±è´¥</b>\n\n` +
          `é”™è¯¯ä¿¡æ¯: ${result.error || 'æœªçŸ¥é”™è¯¯'}\n\n` +
          `è¯·æ£€æŸ¥:\n` +
          `1. æ•°æ®æºURLæ˜¯å¦æ­£ç¡®é…ç½®\n` +
          `2. æ•°æ®æºæ˜¯å¦å¯è®¿é—®\n` +
          `3. æ•°æ®æ ¼å¼æ˜¯å¦æ”¯æŒ`,
          KEYBOARDS.ADMIN_MENU
        );
      }
      
      // åˆ é™¤çŠ¶æ€æ¶ˆæ¯
      if (statusMsg && statusMsg.result && statusMsg.result.message_id) {
        try {
          await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              message_id: statusMsg.result.message_id
            })
          });
        } catch (e) {
          // å¿½ç•¥åˆ é™¤é”™è¯¯
        }
      }
      
    } catch (error) {
      Logger.error("Sync", "åŒæ­¥å¤„ç†å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>æ•°æ®åŒæ­¥å¼‚å¸¸</b>\n\n` +
        `é”™è¯¯ä¿¡æ¯: ${error.message}`,
        KEYBOARDS.ADMIN_MENU
      );
    }
  }

  /**
   * å¤„ç†ç«‹å³æ¨é€
   */
  static async handleForcePush(env, chatId) {
    try {
      let task = await DB.getTask(env);
      
      if (!task) {
        const history = await DB.getHistory(env);
        if (history.length > 0) {
          task = await Controller.initTask(env, history);
        } else {
          await ExternalService.sendMessage(env, chatId, "âŒ æ— å†å²æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆæ¨é€ã€‚è¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚");
          return;
        }
      }

      // æ ‡è®°ä¸ºå®Œæˆå¹¶ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
      task.status = "DONE";
      task.currentSims = task.targetSims;
      
      const allHistory = await DB.getHistory(env);
      const analysis = MathEngine.analyzeBasicStats(allHistory);
      const weights = await DB.getWeights(env);
      const determinants = MathEngine.analyzeDeterminants(allHistory);
      
      task.finalPrediction = PredictionEngine.generate(task, analysis, weights, determinants);
      task.isSent = 1;

      // ä¿å­˜å¹¶å½’æ¡£
      await DB.saveTask(env, task);
      await DB.archivePrediction(env, task.expect, task.finalPrediction);
      
      // æ›´æ–°æ¨é€ç»Ÿè®¡
      const totalPushes = parseInt(await DB.getSetting(env, "TOTAL_PUSHES", "0")) + 1;
      await DB.saveSetting(env, "TOTAL_PUSHES", totalPushes.toString());

      // æ¨é€åˆ°é¢‘é“
      const msgData = MessageRenderer.renderPreview(task.finalPrediction, task, false, weights);
      
      let channelPushSuccess = false;
      if (env.TG_CHANNEL_ID) {
        try {
          await ExternalService.sendMessage(env, env.TG_CHANNEL_ID, msgData.text);
          channelPushSuccess = true;
          Logger.info("Push", `é¢„æµ‹å·²æ¨é€åˆ°é¢‘é“: ${env.TG_CHANNEL_ID}, æœŸå·: ${task.expect}`);
        } catch (error) {
          Logger.error("Push", "æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
          channelPushSuccess = false;
        }
      }
      
      // å‘é€ç¡®è®¤æ¶ˆæ¯ç»™ç®¡ç†å‘˜
      let confirmMessage = `âœ… <b>é¢„æµ‹å·²ç«‹å³æ¨é€</b>\n\n`;
      confirmMessage += `æœŸå·: ${task.expect}\n`;
      confirmMessage += `ç½®ä¿¡åº¦: ${task.finalPrediction.confidence}%\n`;
      confirmMessage += `ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString('zh-CN')}\n`;
      
      if (env.TG_CHANNEL_ID) {
        confirmMessage += `é¢‘é“æ¨é€: ${channelPushSuccess ? 'æˆåŠŸ' : 'å¤±è´¥'}\n`;
      }
      
      confirmMessage += `\nğŸ“Š <b>é¢„æµ‹æ¦‚è§ˆ</b>\n`;
      confirmMessage += `ç”Ÿè‚–: ${task.finalPrediction.zodiac.main.join(", ")}\n`;
      confirmMessage += `æ³¢è‰²: ${CONFIG.EMOJI[task.finalPrediction.color.main]}\n`;
      confirmMessage += `ç‰¹ç ç¤ºä¾‹: ${task.finalPrediction.exampleNumber}\n`;
      
      await ExternalService.sendMessage(env, chatId, confirmMessage);
      
    } catch (error) {
      Logger.error("Push", "ç«‹å³æ¨é€å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>ç«‹å³æ¨é€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†å®šæ—¶è®¾ç½®
   */
  static async handleScheduleSettings(env, chatId, text = null) {
    try {
      if (text) {
        // å¤„ç†å®šæ—¶è®¾ç½®å‘½ä»¤
        if (text.toLowerCase().includes("å…³é—­") || text === "å®šæ—¶å…³é—­") {
          await DB.saveSetting(env, "SCHEDULE_TIME", "OFF");
          await ExternalService.sendMessage(env, chatId, 
            `âœ… å®šæ—¶æ¨é€å·²å…³é—­\n\nè‡ªåŠ¨æ¨é€ä»ä¿æŒå¼€å¯çŠ¶æ€ï¼Œå°†ä½¿ç”¨å³æ—¶æ¨é€æ–¹å¼ã€‚`,
            KEYBOARDS.ADMIN_MENU
          );
          return;
        }
        
        if (text === "æŸ¥çœ‹å®šæ—¶") {
          const scheduleTime = await DB.getSetting(env, "SCHEDULE_TIME", "OFF");
          const lastPush = await DB.getSetting(env, "LAST_SCHEDULE_PUSH", "ä»æœªæ¨é€");
          
          const message = MessageRenderer.renderScheduleSettings(scheduleTime, lastPush);
          await ExternalService.sendMessage(env, chatId, message, KEYBOARDS.SCHEDULE_SETTINGS);
          return;
        }
        
        const timeMatch = text.match(/(\d{1,2}):(\d{2})/);
        if (timeMatch) {
          let hours = parseInt(timeMatch[1]);
          let minutes = parseInt(timeMatch[2]);
          
          if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
            await ExternalService.sendMessage(env, chatId, 
              `âŒ æ—¶é—´èŒƒå›´æ— æ•ˆ\n\n` +
              `å°æ—¶: 0-23ï¼Œåˆ†é’Ÿ: 0-59\n` +
              `ä¾‹å¦‚: <code>å®šæ—¶ 08:00</code> æˆ– <code>å®šæ—¶ 21:30</code>`,
              KEYBOARDS.SCHEDULE_SETTINGS
            );
            return;
          }
          
          const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
          
          await DB.saveSetting(env, "SCHEDULE_TIME", formattedTime);
          
          const message = 
            `âœ… å®šæ—¶æ¨é€æ—¶é—´å·²è®¾ç½®ä¸º: <b>${formattedTime}</b> (åŒ—äº¬æ—¶é—´)\n\n` +
            `æ¯å¤© ${formattedTime} å°†è‡ªåŠ¨æ¨é€é¢„æµ‹ç»“æœ\n\n` +
            `<b>æ³¨æ„äº‹é¡¹:</b>\n` +
            `â€¢ éœ€è¦å…ˆå¼€å¯"è‡ªåŠ¨æ¨é€"\n` +
            `â€¢ å¦‚æœåˆ°æ—¶é¢„æµ‹æœªå®Œæˆï¼Œä¼šç­‰å¾…ä¸‹æ¬¡\n` +
            `â€¢ æ¯å¤©åªä¼šåœ¨è®¾å®šæ—¶é—´æ¨é€ä¸€æ¬¡`;
          
          await ExternalService.sendMessage(env, chatId, message, KEYBOARDS.ADMIN_MENU);
          return;
        }
      }
      
      // æ˜¾ç¤ºå®šæ—¶è®¾ç½®ç•Œé¢
      const scheduleTime = await DB.getSetting(env, "SCHEDULE_TIME", "OFF");
      const lastPush = await DB.getSetting(env, "LAST_SCHEDULE_PUSH", "ä»æœªæ¨é€");
      
      const message = MessageRenderer.renderScheduleSettings(scheduleTime, lastPush);
      await ExternalService.sendMessage(env, chatId, message, KEYBOARDS.SCHEDULE_SETTINGS);
      
    } catch (error) {
      Logger.error("Schedule", "å®šæ—¶è®¾ç½®å¤„ç†å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>å®šæ—¶è®¾ç½®å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†è‡ªåŠ¨æ¨é€åˆ‡æ¢
   */
  static async handleAutoPushToggle(env, chatId) {
    try {
      const currentState = await DB.getSetting(env, "AUTO_PUSH", "ON");
      const newState = currentState === "ON" ? "OFF" : "ON";
      
      await DB.saveSetting(env, "AUTO_PUSH", newState);
      
      let message = "";
      if (newState === "ON") {
        const scheduleTime = await DB.getSetting(env, "SCHEDULE_TIME", "OFF");
        
        message = `ğŸ“¡ <b>è‡ªåŠ¨æ¨é€å·²å¼€å¯</b>\n\n`;
        
        if (scheduleTime === "OFF") {
          message += `å½“å‰æœªè®¾ç½®å®šæ—¶æ¨é€æ—¶é—´\n`;
          message += `è¯·ç‚¹å‡»"${BTNS.SCHEDULE}"è®¾ç½®å®šæ—¶æ—¶é—´\n`;
          message += `æˆ–ä½¿ç”¨å³æ—¶æ¨é€æ–¹å¼`;
        } else {
          message += `å½“å‰å®šæ—¶æ¨é€æ—¶é—´: ${scheduleTime} (åŒ—äº¬æ—¶é—´)\n`;
          message += `æ¯å¤© ${scheduleTime} è‡ªåŠ¨æ¨é€é¢„æµ‹ç»“æœ`;
        }
      } else {
        message = `ğŸ”‡ <b>è‡ªåŠ¨æ¨é€å·²å…³é—­</b>\n\n`;
        message += `å®šæ—¶æ¨é€åŠŸèƒ½ä¹Ÿå·²è‡ªåŠ¨å…³é—­\n`;
        message += `éœ€è¦æ—¶å¯æ‰‹åŠ¨ç‚¹å‡»"${BTNS.PUSH}"æ¨é€`;
        
        // åŒæ—¶å…³é—­å®šæ—¶
        await DB.saveSetting(env, "SCHEDULE_TIME", "OFF");
      }
      
      await ExternalService.sendMessage(env, chatId, message, KEYBOARDS.ADMIN_MENU);
      
    } catch (error) {
      Logger.error("AutoPush", "è‡ªåŠ¨æ¨é€åˆ‡æ¢å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>è‡ªåŠ¨æ¨é€è®¾ç½®å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†æ—¶é•¿è®¾ç½®
   */
  static async handleTimeSetting(env, chatId, hours) {
    try {
      const duration = hours * 3600000;
      await DB.saveSetting(env, "DURATION", duration.toString());
      
      await ExternalService.sendMessage(env, chatId, 
        `âœ… <b>è¿ç®—æ—¶é•¿å·²æ›´æ–°ä¸º: ${hours} å°æ—¶</b>\n\n` +
        `æ­¤è®¾ç½®å¯¹ä¸‹æ¬¡ä»»åŠ¡ç”Ÿæ•ˆã€‚\n` +
        `å½“å‰ä»»åŠ¡ä¸å—å½±å“ã€‚`,
        KEYBOARDS.ADMIN_MENU
      );
      
    } catch (error) {
      Logger.error("TimeSetting", "æ—¶é•¿è®¾ç½®å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>æ—¶é•¿è®¾ç½®å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†é‡ç½®ä»»åŠ¡
   */
  static async handleReset(env, chatId) {
    try {
      const history = await DB.getHistory(env);
      if (history.length === 0) {
        await ExternalService.sendMessage(env, chatId, 
          "âŒ æ— å†å²æ•°æ®ï¼Œæ— æ³•é‡ç½®ä»»åŠ¡ã€‚è¯·å…ˆåŒæ­¥å†å²æ•°æ®ã€‚"
        );
        return;
      }
      
      // é‡æ–°åˆå§‹åŒ–ä»»åŠ¡
      const newTask = await Controller.initTask(env, history);
      
      await ExternalService.sendMessage(env, chatId, 
        `${CONFIG.EMOJI.reset} <b>é¢„æµ‹ä»»åŠ¡å·²é‡ç½®</b>\n\n` +
        `æ–°æœŸå·: ${newTask.expect}\n` +
        `è§£é”æ—¶é—´: ${new Date(newTask.unlockTime).toLocaleString('zh-CN')}\n` +
        `å†å²æ•°æ®: ${history.length} æœŸ\n\n` +
        `ä»»åŠ¡çŠ¶æ€: ${newTask.status}`
      );
      
      Logger.info("Reset", `ä»»åŠ¡å·²é‡ç½®: ${newTask.expect}`);
      
    } catch (error) {
      Logger.error("Reset", "é‡ç½®ä»»åŠ¡å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>é‡ç½®ä»»åŠ¡å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†æˆ˜ç»©ç»Ÿè®¡
   */
  static async handleScoreboard(env, chatId) {
    try {
      const archives = await DB.getArchives(env, 20); // è·å–æœ€è¿‘20æœŸ
      
      if (!archives || archives.length === 0) {
        await ExternalService.sendMessage(env, chatId, 
          `${CONFIG.EMOJI.score} <b>é¢„æµ‹æˆ˜ç»©</b>\n\næš‚æ— å·²å¼€å¥–çš„æˆ˜ç»©è®°å½•ã€‚`
        );
        return;
      }
      
      // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
      let totalMatches = 0;
      let wins = 0;
      let totalScore = 0;
      let maxScore = 0;
      let currentStreak = 0;
      let maxStreak = 0;
      let lastWasWin = false;
      let currentStreakCount = 0;
      
      // æŒ‰æ—¶é—´é¡ºåºï¼ˆä»æ—§åˆ°æ–°ï¼‰è®¡ç®—è¿èƒœ
      const archivesByDate = [...archives].reverse();
      
      archivesByDate.forEach(archive => {
        totalMatches++;
        
        if (archive.result_status === "WIN") {
          wins++;
          totalScore += parseFloat(archive.hit_detail?.match(/\d+/)?.[0] || "0");
          
          const score = parseFloat(archive.hit_detail?.match(/\d+/)?.[0] || "0");
          if (score > maxScore) maxScore = score;
          
          // è¿èƒœè®¡ç®—
          if (lastWasWin || currentStreakCount === 0) {
            currentStreakCount++;
            lastWasWin = true;
          } else {
            currentStreakCount = 1;
            lastWasWin = true;
          }
        } else {
          lastWasWin = false;
          currentStreakCount = 0;
        }
        
        if (currentStreakCount > maxStreak) {
          maxStreak = currentStreakCount;
        }
      });
      
      // å½“å‰è¿èƒœï¼ˆæœ€è¿‘çš„çŠ¶æ€ï¼‰
      const recentArchives = archives.slice(0, 10);
      let recentStreak = 0;
      for (const archive of recentArchives) {
        if (archive.result_status === "WIN") {
          recentStreak++;
        } else {
          break;
        }
      }
      
      const avgScore = totalMatches > 0 ? totalScore / totalMatches : 0;
      const winRate = totalMatches > 0 ? (wins / totalMatches * 100) : 0;
      
      const stats = {
        totalMatches,
        wins,
        winRate: winRate.toFixed(1),
        avgScore: avgScore.toFixed(1),
        maxScore: maxScore.toFixed(0),
        currentStreak: recentStreak,
        maxStreak
      };
      
      const message = MessageRenderer.renderScoreboard(archives, stats);
      await ExternalService.sendMessage(env, chatId, message);
      
    } catch (error) {
      Logger.error("Scoreboard", "æˆ˜ç»©ç»Ÿè®¡å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>è·å–æˆ˜ç»©å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†ç³»ç»ŸçŠ¶æ€
   */
  static async handleSystemStatus(env, chatId) {
    try {
      const stats = await DB.getSystemStats(env);
      const settings = await DB.getAllSettings(env);
      const task = await DB.getTask(env);
      
      if (!stats) {
        await ExternalService.sendMessage(env, chatId, 
          "âŒ æ— æ³•è·å–ç³»ç»ŸçŠ¶æ€ä¿¡æ¯"
        );
        return;
      }
      
      const message = MessageRenderer.renderSystemStatus(stats, settings, task);
      await ExternalService.sendMessage(env, chatId, message);
      
    } catch (error) {
      Logger.error("Status", "ç³»ç»ŸçŠ¶æ€è·å–å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>è·å–ç³»ç»ŸçŠ¶æ€å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }

  /**
   * å¤„ç†AIèŠå¤©
   */
  static async handleAIChat(env, chatId, prompt) {
    try {
      // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºé¢‘é“IDï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥è¿”å›
      if (env.TG_CHANNEL_ID && String(chatId) === String(env.TG_CHANNEL_ID)) {
        Logger.info("AIChat", `æ£€æµ‹åˆ°é¢‘é“æ¶ˆæ¯ï¼Œè·³è¿‡AIå¤„ç†: ${prompt.substring(0, 50)}...`);
        return;
      }
      
      if (!env.AI) {
        await ExternalService.sendMessage(env, chatId, 
          "âš ï¸ AI åŠ©æ‰‹åŠŸèƒ½æœªå¯ç”¨æˆ–æœªé…ç½®ã€‚"
        );
        return;
      }
      
      // å‘é€ç­‰å¾…æ¶ˆæ¯
      const waitMsg = await ExternalService.sendMessage(env, chatId, 
        `${CONFIG.EMOJI.bot} <b>AI åŠ©æ‰‹æ€è€ƒä¸­...</b>\n\nè¯·ç¨å€™ï¼Œæ­£åœ¨åˆ†ææ‚¨çš„é—®é¢˜ã€‚`
      );
      
      // å‡†å¤‡ä¸Šä¸‹æ–‡
      const context = {
        system: CONFIG.SYSTEM.NAME,
        version: CONFIG.SYSTEM.VERSION,
        timestamp: Formatter.formatBeijingTime(),
        userQuestion: prompt
      };
      
      // è·å–ç³»ç»ŸçŠ¶æ€ä½œä¸ºé¢å¤–ä¸Šä¸‹æ–‡
      try {
        const stats = await DB.getSystemStats(env);
        if (stats) {
          context.systemStats = stats;
        }
      } catch (e) {
        // å¿½ç•¥ç»Ÿè®¡è·å–é”™è¯¯
      }
      
      // è°ƒç”¨AI
      const aiResponse = await ExternalService.callAI(env, prompt, context);
      
      // æ„å»ºå“åº”æ¶ˆæ¯
      const responseMessage = 
        `${CONFIG.EMOJI.bot} <b>AI åˆ†æç»“æœ</b>\n\n` +
        `${aiResponse}\n\n` +
        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n` +
        `<i>${CONFIG.SYSTEM.NAME} AIåŠ©æ‰‹ | ${Formatter.formatBeijingTime()}</i>`;
      
      // å‘é€å“åº”
      await ExternalService.sendMessage(env, chatId, responseMessage);
      
      // åˆ é™¤ç­‰å¾…æ¶ˆæ¯
      if (waitMsg && waitMsg.result && waitMsg.result.message_id) {
        try {
          await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/deleteMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              message_id: waitMsg.result.message_id
            })
          });
        } catch (e) {
          // å¿½ç•¥åˆ é™¤é”™è¯¯
        }
      }
      
    } catch (error) {
      Logger.error("AIChat", "AIèŠå¤©å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>AI åŠ©æ‰‹æš‚æ—¶æ— æ³•å“åº”</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message || 'æœªçŸ¥é”™è¯¯'}</code>\n\nè¯·ç¨åé‡è¯•ã€‚`
      );
    }
  }

  /**
   * å¤„ç†å¸®åŠ©ä¿¡æ¯
   */
  static async handleHelp(env, chatId) {
    try {
      const helpMessage = MessageRenderer.renderHelp();
      await ExternalService.sendMessage(env, chatId, helpMessage);
    } catch (error) {
      Logger.error("Help", "å¸®åŠ©ä¿¡æ¯å‘é€å¤±è´¥", error);
      await ExternalService.sendMessage(env, chatId, 
        `âŒ <b>è·å–å¸®åŠ©ä¿¡æ¯å¤±è´¥</b>\n\né”™è¯¯ä¿¡æ¯: <code>${error.message}</code>`
      );
    }
  }
}

// ==============================================================================
// 9. äº‹ä»¶å¤„ç†å™¨ (Event Handlers) - å®Œæ•´ç‰ˆï¼ˆå·²ä¿®å¤ï¼‰
// ==============================================================================

/**
 * å¤„ç†å›è°ƒæŸ¥è¯¢ï¼ˆæŒ‰é’®ç‚¹å‡»ï¼‰
 */
async function handleCallback(env, query) {
  const data = query.data;
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;
  
  Logger.info("Callback", `æ”¶åˆ°å›è°ƒ: ${data}, chatId: ${chatId}, messageId: ${messageId}`);
  
  // ç«‹å³å“åº”å›è°ƒï¼Œé˜²æ­¢è¶…æ—¶
  try {
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†ä¸­...");
  } catch (e) {
    Logger.error("Callback", "å›ç­”å›è°ƒå¤±è´¥", e);
  }
  
  // å¤„ç†ä¸åŒå›è°ƒç±»å‹
  try {
    if (data === 'refresh_preview') {
      // åˆ·æ–°é¢„è§ˆ
      await Controller.handlePreview(env, chatId, messageId);
      
    } else if (data === 'view_details') {
      // æŸ¥çœ‹é¢„æµ‹è¯¦æƒ…
      const task = await DB.getTask(env);
      if (task && task.finalPrediction) {
        const details = MessageRenderer.renderPredictionDetails(task.finalPrediction);
        await ExternalService.editMessage(env, chatId, messageId, details.text, details.keyboard);
      } else {
        await ExternalService.answerCallbackQuery(env, query.id, "æš‚æ— é¢„æµ‹è¯¦æƒ…", true);
      }
      
    } else if (data === 'back_to_preview') {
      // è¿”å›é¢„æµ‹é¢„è§ˆ
      await Controller.handlePreview(env, chatId, messageId);
      
    } else if (data.startsWith('history_page_')) {
      // å†å²è®°å½•ç¿»é¡µ
      const page = parseInt(data.replace('history_page_', ''));
      await Controller.handleHistory(env, chatId, page, messageId);
      
    } else if (data === 'back_to_menu') {
      // è¿”å›èœå•
      await ExternalService.sendMessage(env, chatId, `ğŸ“‚ <b>${CONFIG.SYSTEM.NAME}</b> ä¸»èœå•`, KEYBOARDS.MAIN_MENU);
      
    } else {
      // æœªçŸ¥å›è°ƒ
      await ExternalService.answerCallbackQuery(env, query.id, "æœªçŸ¥æ“ä½œ", true);
    }
  } catch (error) {
    Logger.error("Callback", "å¤„ç†å›è°ƒå¤±è´¥", error);
    await ExternalService.answerCallbackQuery(env, query.id, "å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", true);
  }
}

/**
 * å¤„ç†ä¸»æ›´æ–°å¾ªç¯
 */
async function handleUpdate(env, payload, ctx) {
  // 1. å¤„ç†å›è°ƒæŸ¥è¯¢
  if (payload.callback_query) {
    await handleCallback(env, payload.callback_query);
    return;
  }

  // 2. éªŒè¯æ¶ˆæ¯æœ‰æ•ˆæ€§
  const msg = payload.message || payload.channel_post;
  if (!msg || !msg.text) return;

  const chatId = msg.chat.id;
  const text = msg.text.trim();
  const userId = msg.from ? String(msg.from.id) : "CHANNEL";
  
  Logger.info("Update", `æ”¶åˆ°æ¶ˆæ¯: ${text}, chatId: ${chatId}, userId: ${userId}`);
  
  // 3. æƒé™æ£€æŸ¥
  const isAdmin = (String(msg.from?.id) === String(env.TG_ADMIN_ID));
  
  // 4. çŠ¶æ€æœºæ£€æŸ¥
  const userState = userStateManager.getState(chatId);
  
  // å¤„ç†å®šæ—¶è®¾ç½®çŠ¶æ€
  if (userState && userState.state === "WAITING_SCHEDULE_TIME") {
    userStateManager.deleteState(chatId);
    await Controller.handleScheduleSettings(env, chatId, text);
    return;
  }
  
  // 5. å‘½ä»¤è·¯ç”±
  
  // --- å¤ç›˜å›æµ‹æŒ‡ä»¤ ---
  if (text.startsWith("å¤ç›˜")) {
    const match = text.match(/å¤ç›˜\s*(\d+)/);
    if (match) {
      ctx.waitUntil(Controller.handleBacktest(env, chatId, match[1]));
    } else {
      await ExternalService.sendMessage(env, chatId, 
        "âŒ <b>æ ¼å¼é”™è¯¯</b>\n\n" +
        "è¯·ä½¿ç”¨: <code>å¤ç›˜ æœŸå·</code>\n" +
        "ä¾‹å¦‚: <code>å¤ç›˜ 2024130</code>\n\n" +
        "åŠŸèƒ½è¯´æ˜: ç³»ç»Ÿä¼šå›åˆ°è¯¥æœŸï¼Œæ¨¡æ‹Ÿå½“æ—¶çš„é¢„æµ‹ç¯å¢ƒï¼Œå¹¶ä¸çœŸå®ç»“æœå¯¹æ¯”ï¼Œè‡ªåŠ¨å­¦ä¹ ä¼˜åŒ–ã€‚"
      );
    }
    return;
  }
  
  // --- å¯¼èˆªæŒ‡ä»¤ ---
  if (text === "/start" || text.includes("è¿”å›å¤§å…")) {
    await ExternalService.sendMessage(env, chatId, 
      `ğŸ  <b>${CONFIG.SYSTEM.NAME}</b>\n\n` +
      `ç³»ç»Ÿç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n` +
      `æ ¸å¿ƒåŠŸèƒ½: æ™ºèƒ½é¢„æµ‹ + æ—¶å…‰æœºå¤ç›˜ + è‡ªä¸»å­¦ä¹ \n\n` +
      `è¯·é€‰æ‹©åŠŸèƒ½å¼€å§‹ä½¿ç”¨ã€‚`,
      KEYBOARDS.LOBBY
    );
    return;
  }
  
  if (text.includes("AI åŠ©æ‰‹")) {
    await ExternalService.sendMessage(env, chatId, 
      `${CONFIG.EMOJI.bot} <b>AI å¯¹è¯æ¨¡å¼</b>\n\n` +
      `è¯·ç›´æ¥å‘é€æ‚¨çš„é—®é¢˜ï¼Œæˆ‘ä¼šä»æ•°æ®åˆ†æã€æ¦‚ç‡å­¦è§’åº¦ä¸ºæ‚¨è§£ç­”ã€‚\n\n` +
      `<b>å¯ä»¥å’¨è¯¢:</b>\n` +
      `â€¢ é¢„æµ‹ç®—æ³•åŸç†\n` +
      `â€¢ æ•°æ®ç»Ÿè®¡è§„å¾‹\n` +
      `â€¢ ç³»ç»Ÿä½¿ç”¨æ–¹æ³•\n` +
      `â€¢ å…¶ä»–ç›¸å…³é—®é¢˜`,
      KEYBOARDS.AI_CHAT
    );
    return;
  }
  
  if (text === CONFIG.SYSTEM.NAME || text.includes("è¿”å›èœå•")) {
    await ExternalService.sendMessage(env, chatId, 
      `ğŸ“‚ <b>${CONFIG.SYSTEM.NAME} ä¸»èœå•</b>\n\n` +
      `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n` +
      `é€‰æ‹©åŠŸèƒ½å¼€å§‹ä½¿ç”¨ã€‚`,
      KEYBOARDS.MAIN_MENU
    );
    return;
  }
  
  if (text === BTNS.HELP) {
    ctx.waitUntil(Controller.handleHelp(env, chatId));
    return;
  }
  
  if (text === BTNS.STATUS) {
    ctx.waitUntil(Controller.handleSystemStatus(env, chatId));
    return;
  }
  
  // --- æ™®é€šç”¨æˆ·åŠŸèƒ½ ---
  if (text === BTNS.REC) {
    await Controller.handleHistory(env, chatId, 1);
    return;
  }
  
  if (text === BTNS.PREVIEW) {
    await Controller.handlePreview(env, chatId);
    return;
  }
  
  if (text === BTNS.SCORE) {
    ctx.waitUntil(Controller.handleScoreboard(env, chatId));
    return;
  }
  
  // --- ç®¡ç†å‘˜åŠŸèƒ½ ---
  if (isAdmin) {
    if (text === BTNS.MANAGE) {
      await ExternalService.sendMessage(env, chatId, 
        `${CONFIG.EMOJI.manage} <b>ç³»ç»Ÿç®¡ç†åå°</b>\n\n` +
        `ç‰ˆæœ¬: ${CONFIG.SYSTEM.VERSION}\n` +
        `é€‰æ‹©åŠŸèƒ½è¿›è¡Œç®¡ç†ã€‚`,
        KEYBOARDS.ADMIN_MENU
      );
      return;
    }
    
    if (text === BTNS.SYNC) {
      ctx.waitUntil(Controller.handleSync(env, chatId));
      return;
    }
    
    if (text === BTNS.RESET) {
      ctx.waitUntil(Controller.handleReset(env, chatId));
      return;
    }
    
    if (text === BTNS.PUSH) {
      ctx.waitUntil(Controller.handleForcePush(env, chatId));
      return;
    }
    
    if (text === BTNS.AUTO) {
      ctx.waitUntil(Controller.handleAutoPushToggle(env, chatId));
      return;
    }
    
    if (text === BTNS.TIME) {
      await ExternalService.sendMessage(env, chatId, 
        `${CONFIG.EMOJI.clock} <b>è®¾ç½®è¿ç®—æ—¶é•¿</b>\n\n` +
        `é€‰æ‹©é¢„æµ‹è®¡ç®—æ—¶é•¿ï¼ˆå°æ—¶ï¼‰\n` +
        `å½“å‰è®¾ç½®å½±å“ä»»åŠ¡è§£é”æ—¶é—´ã€‚`,
        KEYBOARDS.TIME_SETTINGS
      );
      return;
    }
    
    if (text.startsWith("SET_DUR_")) {
      const match = text.match(/SET_DUR_(\d+)/);
      if (match) {
        const hours = parseInt(match[1]);
        if (hours > 0 && hours <= 24) {
          await Controller.handleTimeSetting(env, chatId, hours);
        }
      }
      return;
    }
    
    if (text === BTNS.SCHEDULE) {
      await Controller.handleScheduleSettings(env, chatId);
      return;
    }
    
    if (text.includes("å®šæ—¶")) {
      // è¿›å…¥å®šæ—¶è®¾ç½®çŠ¶æ€
      userStateManager.setState(chatId, { 
        state: "WAITING_SCHEDULE_TIME",
        data: { action: "schedule" }
      });
      await Controller.handleScheduleSettings(env, chatId, text);
      return;
    }
    
    if (text === BTNS.LEARN) {
      ctx.waitUntil(Controller.handleForceLearn(env, chatId));
      return;
    }
  } else {
    // éç®¡ç†å‘˜å°è¯•ä½¿ç”¨ç®¡ç†å‘˜åŠŸèƒ½
    const adminCommands = [BTNS.MANAGE, BTNS.SYNC, BTNS.RESET, BTNS.PUSH, BTNS.AUTO, 
                          BTNS.TIME, BTNS.SCHEDULE, BTNS.LEARN];
    if (adminCommands.includes(text) || text.startsWith("SET_DUR_")) {
      await ExternalService.sendMessage(env, chatId, 
        "ğŸš« <b>æƒé™ä¸è¶³</b>\n\næ­¤åŠŸèƒ½ä»…é™ç®¡ç†å‘˜ä½¿ç”¨ã€‚"
      );
      return;
    }
  }
  
  // --- AI èŠå¤©ï¼ˆå¦‚æœä¸æ˜¯å‘½ä»¤ï¼‰ ---
  if (env.AI && !text.startsWith("/")) {
    ctx.waitUntil(Controller.handleAIChat(env, chatId, text));
  }
}

/**
 * å¤„ç†å®šæ—¶ä»»åŠ¡
 */
async function handleCronJob(env) {
  Logger.info("Cron", "å¼€å§‹æ‰§è¡Œå®šæ—¶ä»»åŠ¡");
  
  try {
    // 1. å¤„ç†é¢„æµ‹ä»»åŠ¡è¿›åº¦
    let task = await DB.getTask(env);
    if (task && task.status === "CALCULATING") {
      // æ›´æ–°ä»»åŠ¡è¿›åº¦
      const timePassed = Date.now() - task.startTime;
      const totalDuration = task.unlockTime - task.startTime;
      const progress = Math.min(1, timePassed / totalDuration);
      
      task.currentSims = Math.min(task.targetSims, Math.floor(progress * task.targetSims));
      
      // æ£€æŸ¥æ˜¯å¦å®Œæˆ
      if (Date.now() >= task.unlockTime) {
        task.status = "DONE";
        task.currentSims = task.targetSims;
        
        // ç”Ÿæˆæœ€ç»ˆé¢„æµ‹
        const allHistory = await DB.getHistory(env);
        const analysis = MathEngine.analyzeBasicStats(allHistory);
        const weights = await DB.getWeights(env);
        const determinants = MathEngine.analyzeDeterminants(allHistory);
        
        task.finalPrediction = PredictionEngine.generate(task, analysis, weights, determinants);
        
        // å½’æ¡£
        await DB.archivePrediction(env, task.expect, task.finalPrediction);
        
        Logger.info("Cron", `ä»»åŠ¡å®Œæˆ: ${task.expect}, ç½®ä¿¡åº¦: ${task.finalPrediction.confidence}%`);
      }
      
      await DB.saveTask(env, task);
    }
    
    // 2. å¤„ç†å®šæ—¶æ¨é€
    const autoPush = await DB.getSetting(env, "AUTO_PUSH", "ON");
    const scheduleTime = await DB.getSetting(env, "SCHEDULE_TIME", "OFF");
    
    if (autoPush === "ON" && scheduleTime !== "OFF") {
      // è·å–å½“å‰åŒ—äº¬æ—¶é—´
      const now = Formatter.getBeijingTime();
      const currentTimeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
      const todayStr = now.toISOString().split('T')[0];
      
      if (currentTimeStr === scheduleTime) {
        const lastPushDate = await DB.getSetting(env, "LAST_SCHEDULE_PUSH", "");
        
        // ç¡®ä¿ä»Šå¤©æ²¡æ¨è¿‡ï¼Œä¸”ä»»åŠ¡å·²å®Œæˆ
        if (lastPushDate !== todayStr && task && task.status === "DONE" && !task.isSent) {
          Logger.info("Cron", `åˆ°è¾¾å®šæ—¶æ¨é€æ—¶é—´ ${scheduleTime}, å¼€å§‹æ¨é€`);
          
          const weights = await DB.getWeights(env);
          const msgData = MessageRenderer.renderPreview(task.finalPrediction, task, false, weights);
          
          if (env.TG_CHANNEL_ID) {
            try {
              await ExternalService.sendMessage(env, env.TG_CHANNEL_ID, msgData.text);
              
              // æ›´æ–°çŠ¶æ€
              task.isSent = 1;
              await DB.saveTask(env, task);
              await DB.saveSetting(env, "LAST_SCHEDULE_PUSH", todayStr);
              
              // æ›´æ–°æ¨é€ç»Ÿè®¡
              const totalPushes = parseInt(await DB.getSetting(env, "TOTAL_PUSHES", "0")) + 1;
              await DB.saveSetting(env, "TOTAL_PUSHES", totalPushes.toString());
              
              Logger.info("Cron", `å®šæ—¶æ¨é€å®Œæˆ: ${task.expect} åˆ°é¢‘é“ ${env.TG_CHANNEL_ID}`);
            } catch (error) {
              Logger.error("Cron", "å®šæ—¶æ¨é€åˆ°é¢‘é“å¤±è´¥", error);
            }
          }
        }
      }
    }
    
    // 3. è‡ªåŠ¨å½’æ¡£æˆ˜ç»©
    const lastArchiveCheck = await DB.getSetting(env, "LAST_ARCHIVE_CHECK", "0");
    const checkInterval = 24 * 60 * 60 * 1000; // 24å°æ—¶æ£€æŸ¥ä¸€æ¬¡
    
    if (Date.now() - parseInt(lastArchiveCheck) > checkInterval) {
      Logger.info("Cron", "å¼€å§‹è‡ªåŠ¨å½’æ¡£æ£€æŸ¥");
      
      try {
        // è¿™é‡Œå¯ä»¥æ·»åŠ è‡ªåŠ¨å½’æ¡£é€»è¾‘ï¼Œæ¯”å¦‚æ£€æŸ¥æœªå½’æ¡£çš„é¢„æµ‹ç­‰
        await DB.saveSetting(env, "LAST_ARCHIVE_CHECK", Date.now().toString());
      } catch (error) {
        Logger.error("Cron", "è‡ªåŠ¨å½’æ¡£æ£€æŸ¥å¤±è´¥", error);
      }
    }
    
    Logger.info("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ");
    
  } catch (error) {
    Logger.error("Cron", "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå¤±è´¥", error);
  }
}

/**
 * åˆå§‹åŒ–æ•°æ®åº“
 */
async function initDatabase(env) {
  if (!env.DB) {
    Logger.error("Init", "Database binding 'DB' not found");
    return false;
  }
  
  try {
    // åˆ›å»ºè¡¨
    const statements = [
      // å†å²å¼€å¥–è®°å½•è¡¨
      `CREATE TABLE IF NOT EXISTS lottery_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT, 
        expect TEXT UNIQUE, 
        open_code TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
      
      // åˆ›å»ºç´¢å¼•
      `CREATE INDEX IF NOT EXISTS idx_history_expect ON lottery_history (expect DESC)`,
      `CREATE INDEX IF NOT EXISTS idx_history_created ON lottery_history (created_at DESC)`,
      
      // é¢„æµ‹ä»»åŠ¡è¡¨
      `CREATE TABLE IF NOT EXISTS lottery_tasks (
        id INTEGER PRIMARY KEY DEFAULT 1, 
        data TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
      
      // é¢„æµ‹å½’æ¡£è¡¨
      `CREATE TABLE IF NOT EXISTS prediction_archives (
        id INTEGER PRIMARY KEY AUTOINCREMENT, 
        expect TEXT UNIQUE, 
        prediction_json TEXT, 
        result_status TEXT DEFAULT 'PENDING', 
        hit_detail TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
      
      // åˆ›å»ºç´¢å¼•
      `CREATE INDEX IF NOT EXISTS idx_archives_expect ON prediction_archives (expect DESC)`,
      `CREATE INDEX IF NOT EXISTS idx_archives_status ON prediction_archives (result_status)`,
      `CREATE INDEX IF NOT EXISTS idx_archives_created ON prediction_archives (created_at DESC)`,
      
      // ç³»ç»Ÿè®¾ç½®è¡¨
      `CREATE TABLE IF NOT EXISTS lottery_settings (
        setting_key TEXT PRIMARY KEY, 
        value TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`
    ];
    
    // æ‰¹é‡æ‰§è¡Œ
    const batch = statements.map(sql => env.DB.prepare(sql));
    await env.DB.batch(batch);
    
    // åˆå§‹åŒ–é»˜è®¤è®¾ç½®
    await DB.initDefaultSettings(env);
    
    Logger.info("Init", "æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ");
    return true;
    
  } catch (error) {
    Logger.error("Init", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", error);
    return false;
  }
}

// ==============================================================================
// 10. Worker å…¥å£ç‚¹ (Entry Point) - å®Œæ•´ç‰ˆ
// ==============================================================================

export default {
  /**
   * å®šæ—¶è§¦å‘å…¥å£
   */
  async scheduled(event, env, ctx) {
    Logger.info("Worker", "å®šæ—¶ä»»åŠ¡è§¦å‘");
    
    // åˆå§‹åŒ–æ•°æ®åº“
    const initialized = await initDatabase(env);
    if (!initialized) {
      Logger.error("Worker", "æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œå®šæ—¶ä»»åŠ¡ä¸­æ­¢");
      return;
    }
    
    // æ‰§è¡Œå®šæ—¶ä»»åŠ¡
    ctx.waitUntil(handleCronJob(env));
  },

  /**
   * HTTP è¯·æ±‚å…¥å£
   */
  async fetch(request, env, ctx) {
    // è®°å½•è¯·æ±‚ä¿¡æ¯
    const url = new URL(request.url);
    Logger.info("Worker", `æ”¶åˆ°è¯·æ±‚: ${request.method} ${url.pathname}`);
    
    // åˆå§‹åŒ–æ•°æ®åº“
    const initialized = await initDatabase(env);
    if (!initialized) {
      return new Response("Database Initialization Failed. Please check D1 binding.", { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
    
    // è®¾ç½®ç¯å¢ƒå˜é‡
    CONFIG.SYSTEM.CHANNEL_ID = env.TG_CHANNEL_ID;
    CONFIG.SYSTEM.ADMIN_ID = env.TG_ADMIN_ID;
    
    // GET è¯·æ±‚å¤„ç†
    if (request.method === "GET") {
      // æ‰‹åŠ¨åŒæ­¥æ¥å£
      if (url.pathname === '/sync') {
        if (!env.TG_ADMIN_ID) {
          return new Response('æœªé…ç½®ç®¡ç†å‘˜ID', { status: 403 });
        }
        
        try {
          const result = await ExternalService.syncHistoryFromUrl(env);
          
          let html = `<h1>${CONFIG.SYSTEM.NAME} - æ•°æ®åŒæ­¥ç»“æœ</h1>`;
          html += `<style>body{font-family:Arial,sans-serif;margin:40px;line-height:1.6}</style>`;
          
          if (result.success) {
            html += `<p style="color:green;font-weight:bold;">âœ… åŒæ­¥æˆåŠŸ</p>`;
            html += `<p>è·å–æ€»æ•°: ${result.total} æ¡</p>`;
            html += `<p>æˆåŠŸæ–°å¢: ${result.added} æ¡</p>`;
            html += `<p>è·³è¿‡é‡å¤: ${result.skipped || 0} æ¡</p>`;
            
            if (result.newCount > 0) {
              html += `<p style="color:blue;">ğŸ“¢ å‘ç° ${result.newCount} æ¡æ–°å¼€å¥–è®°å½•</p>`;
            }
            
            const history = await DB.getHistory(env);
            if (history.length > 0) {
              await Controller.initTask(env, history);
              html += `<p>ğŸ”„ é¢„æµ‹ä»»åŠ¡å·²é‡æ–°åˆå§‹åŒ–</p>`;
            }
          } else {
            html += `<p style="color:red;font-weight:bold;">âŒ åŒæ­¥å¤±è´¥</p>`;
            html += `<p>é”™è¯¯: ${result.error || 'æœªçŸ¥é”™è¯¯'}</p>`;
            
            if (result.stack) {
              html += `<details><summary>é”™è¯¯è¯¦æƒ…</summary><pre>${result.stack}</pre></details>`;
            }
          }
          
          html += `<hr><p><a href="/">è¿”å›é¦–é¡µ</a> | <a href="/health">å¥åº·æ£€æŸ¥</a></p>`;
          
          return new Response(html, { 
            status: result.success ? 200 : 500,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        } catch (error) {
          return new Response(`åŒæ­¥å‡ºé”™: ${error.message}`, { status: 500 });
        }
      }
      
      // å¥åº·æ£€æŸ¥æ¥å£
      if (url.pathname === '/health') {
        try {
          const stats = await DB.getSystemStats(env);
          const settings = await DB.getAllSettings(env);
          const task = await DB.getTask(env);
          
          const healthData = {
            status: 'healthy',
            service: CONFIG.SYSTEM.NAME,
            version: CONFIG.SYSTEM.VERSION,
            timestamp: Formatter.formatBeijingTime(),
            database: {
              initialized: true,
              historyCount: stats?.historyCount || 0,
              archiveCount: stats?.archiveCount || 0,
              latestExpect: stats?.latestExpect || 'æ— æ•°æ®'
            },
            task: task ? {
              expect: task.expect,
              status: task.status,
              progress: task.targetSims > 0 ? 
                `${((task.currentSims / task.targetSims) * 100).toFixed(1)}%` : '0%',
              unlockTime: new Date(task.unlockTime).toLocaleString('zh-CN')
            } : null,
            features: ['æ™ºèƒ½é¢„æµ‹', 'æ—¶å…‰æœºå¤ç›˜', 'è‡ªä¸»å­¦ä¹ ', 'å®šæ—¶æ¨é€', 'AIåŠ©æ‰‹'],
            settings: {
              autoPush: settings.AUTO_PUSH || 'ON',
              scheduleTime: settings.SCHEDULE_TIME || 'OFF',
              duration: `${parseInt(settings.DURATION || CONFIG.SYSTEM.DEFAULT_DURATION) / 3600000}å°æ—¶`,
              totalSyncs: settings.TOTAL_SYNCS || '0',
              totalPushes: settings.TOTAL_PUSHES || '0'
            }
          };
          
          return new Response(JSON.stringify(healthData, null, 2), { 
            status: 200,
            headers: { 
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
        } catch (error) {
          return new Response(JSON.stringify({ 
            status: 'error',
            error: error.message,
            timestamp: new Date().toISOString()
          }), { 
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
      
      // Webhookè®¾ç½®æ¥å£
      if (url.searchParams.get('setwebhook') === 'true' && env.TG_BOT_TOKEN) {
        const webhookUrl = `${url.origin}`;
        try {
          const set = await fetch(`https://api.telegram.org/bot${env.TG_BOT_TOKEN}/setWebhook?url=${webhookUrl}`);
          const result = await set.json();
          return new Response(JSON.stringify(result, null, 2), { 
            status: 200,
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (e) {
          return new Response(JSON.stringify({ error: e.message }), { status: 500 });
        }
      }
      
      // é»˜è®¤é¦–é¡µ
      return new Response(`
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${CONFIG.SYSTEM.NAME}</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
              max-width: 800px;
              margin: 0 auto;
              padding: 20px;
              line-height: 1.6;
              color: #333;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              min-height: 100vh;
            }
            .container {
              background: white;
              border-radius: 15px;
              padding: 40px;
              box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            }
            h1 {
              color: #2d3748;
              border-bottom: 3px solid #667eea;
              padding-bottom: 10px;
              margin-top: 0;
            }
            h2 {
              color: #4a5568;
              margin-top: 30px;
            }
            .feature-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
              gap: 20px;
              margin: 30px 0;
            }
            .feature-card {
              background: #f7fafc;
              border-left: 4px solid #667eea;
              padding: 20px;
              border-radius: 8px;
              transition: transform 0.2s;
            }
            .feature-card:hover {
              transform: translateY(-5px);
              box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            }
            .feature-icon {
              font-size: 24px;
              margin-bottom: 10px;
            }
            .nav-links {
              display: flex;
              gap: 15px;
              margin-top: 30px;
              flex-wrap: wrap;
            }
            .btn {
              display: inline-block;
              padding: 12px 24px;
              background: #667eea;
              color: white;
              text-decoration: none;
              border-radius: 8px;
              font-weight: bold;
              transition: background 0.2s;
            }
            .btn:hover {
              background: #5a67d8;
            }
            .btn-secondary {
              background: #718096;
            }
            .btn-secondary:hover {
              background: #4a5568;
            }
            .version {
              color: #718096;
              font-size: 14px;
              margin-top: 30px;
              padding-top: 20px;
              border-top: 1px solid #e2e8f0;
            }
            .highlight {
              color: #667eea;
              font-weight: bold;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>${CONFIG.SYSTEM.NAME}</h1>
            <p><strong>ç‰ˆæœ¬:</strong> ${CONFIG.SYSTEM.VERSION} - ä¼ä¸šå®Œæ•´ç‰ˆ</p>
            <p>è¿™æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å…­åˆå½©æ•°æ®åˆ†æä¸é¢„æµ‹ç³»ç»Ÿï¼Œé‡‡ç”¨å…ˆè¿›çš„ç®—æ³•å’Œæœºå™¨å­¦ä¹ æŠ€æœ¯ï¼Œæä¾›å‡†ç¡®çš„é¢„æµ‹å’Œåˆ†ææœåŠ¡ã€‚</p>
            
            <h2>ğŸ¯ æ ¸å¿ƒç‰¹ç‚¹</h2>
            <div class="feature-grid">
              <div class="feature-card">
                <div class="feature-icon">ğŸ¤–</div>
                <h3>æ™ºèƒ½é¢„æµ‹å¼•æ“</h3>
                <p>åŸºäºé©¬å°”å¯å¤«é“¾ã€é—æ¼å€¼å›å½’å’ŒåŠ¨æ€æƒé‡ç®—æ³•ï¼Œæä¾›é«˜å‡†ç¡®ç‡é¢„æµ‹ã€‚</p>
              </div>
              <div class="feature-card">
                <div class="feature-icon">â°</div>
                <h3>æ—¶å…‰æœºå¤ç›˜</h3>
                <p>å¯ä»¥å›åˆ°ä»»æ„å†å²æœŸæ•°è¿›è¡Œæ¨¡æ‹Ÿé¢„æµ‹ï¼ŒéªŒè¯ç®—æ³•å‡†ç¡®æ€§ã€‚</p>
              </div>
              <div class="feature-card">
                <div class="feature-icon">ğŸ§ </div>
                <h3>è‡ªä¸»å­¦ä¹ </h3>
                <p>é¢„æµ‹å¤±è´¥è‡ªåŠ¨åˆ†æåŸå› ï¼ŒåŠ¨æ€è°ƒæ•´ç®—æ³•å‚æ•°ï¼ŒæŒç»­ä¼˜åŒ–å‡†ç¡®ç‡ã€‚</p>
              </div>
              <div class="feature-card">
                <div class="feature-icon">ğŸ“¡</div>
                <h3>å®šæ—¶æ¨é€</h3>
                <p>æ”¯æŒå®šæ—¶è‡ªåŠ¨æ¨é€é¢„æµ‹ç»“æœï¼Œå®Œæ•´çš„æ¨é€ç®¡ç†ç³»ç»Ÿã€‚</p>
              </div>
            </div>
            
            <h2>ğŸš€ ä¸»è¦åŠŸèƒ½</h2>
            <ul>
              <li><span class="highlight">æ™ºèƒ½é¢„æµ‹åˆ†æ</span> - åŸºäºå†å²æ•°æ®çš„å¤šç»´åº¦åˆ†æ</li>
              <li><span class="highlight">å†å²æ•°æ®åŒæ­¥</span> - ä»URLè‡ªåŠ¨åŒæ­¥å¼€å¥–è®°å½•</li>
              <li><span class="highlight">æˆ˜ç»©ç»Ÿè®¡ç³»ç»Ÿ</span> - è¯¦ç»†è®°å½•é¢„æµ‹å‡†ç¡®ç‡</li>
              <li><span class="highlight">AIåŠ©æ‰‹é›†æˆ</span> - æ™ºèƒ½é—®ç­”å’Œæ•°æ®è§£é‡Š</li>
              <li><span class="highlight">å®Œæ•´ç®¡ç†åå°</span> - ç®¡ç†å‘˜ä¸“ç”¨åŠŸèƒ½ç•Œé¢</li>
              <li><span class="highlight">å®æ—¶è¿›åº¦è·Ÿè¸ª</span> - é¢„æµ‹ç”Ÿæˆè¿›åº¦å¯è§†åŒ–</li>
            </ul>
            
            <div class="nav-links">
              <a href="/health" class="btn">ğŸ¥ å¥åº·æ£€æŸ¥</a>
              <a href="/sync" class="btn">ğŸ”„ æ‰‹åŠ¨åŒæ­¥æ•°æ®</a>
              <a href="https://core.telegram.org/bots" target="_blank" class="btn-secondary">ğŸ“š Telegram Bot API</a>
            </div>
            
            <div class="version">
              <p><strong>æŠ€æœ¯æ ˆ:</strong> Cloudflare Workers + D1 Database + AI + Telegram Bot API</p>
              <p><strong>ç®—æ³•ç‰ˆæœ¬:</strong> V5.0 ä¼ä¸šç‰ˆ (é©¬å°”å¯å¤«é“¾ + é—æ¼å€¼å›å½’ + åŠ¨æ€æƒé‡è°ƒæ•´)</p>
              <p><strong>æ•°æ®å®‰å…¨:</strong> æ‰€æœ‰æ•°æ®åŠ å¯†å­˜å‚¨ï¼Œæ— ä¸ªäººä¿¡æ¯æ”¶é›†</p>
              <p><strong>æœ€åæ›´æ–°:</strong> ${new Date().toLocaleDateString('zh-CN')}</p>
            </div>
          </div>
        </body>
        </html>
      `, { 
        status: 200,
        headers: { 
          'Content-Type': 'text/html; charset=utf-8',
          'Cache-Control': 'no-cache'
        }
      });
    }

    // POSTè¯·æ±‚å¤„ç†ï¼ˆTelegram Webhookï¼‰
    if (request.method === "POST") {
      try {
        const payload = await request.json();
        
        // å¼‚æ­¥å¤„ç†ï¼Œç«‹å³è¿”å›200å“åº”ç»™Telegram
        ctx.waitUntil(handleUpdate(env, payload, ctx));
        
        return new Response("OK", { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      } catch (e) {
        Logger.error("Webhook", "å¤„ç†POSTè¯·æ±‚å‡ºé”™", e);
        return new Response("OK", { status: 200 }); // å§‹ç»ˆè¿”å›OKç»™Telegram
      }
    }
    
    return new Response("Method not allowed", { status: 405 });
  }
};
